diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/etc/mtree/BSD.include.dist freebsd-10.1.0-LISP/etc/mtree/BSD.include.dist
--- freebsd-10.1.0-RELEASE/etc/mtree/BSD.include.dist	2014-12-05 22:07:18.904659325 +0100
+++ freebsd-10.1.0-LISP/etc/mtree/BSD.include.dist	2014-12-14 13:47:08.797151040 +0100
@@ -254,6 +254,8 @@
         ..
     ..
     net
+        lisp
+	..
     ..
     net80211
     ..
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/include/Makefile freebsd-10.1.0-LISP/include/Makefile
--- freebsd-10.1.0-RELEASE/include/Makefile	2014-12-05 22:16:26.086117903 +0100
+++ freebsd-10.1.0-LISP/include/Makefile	2014-12-14 13:47:08.797151040 +0100
@@ -53,6 +53,7 @@
 	geom/mirror geom/mountver geom/multipath geom/nop \
 	geom/raid geom/raid3 geom/shsec geom/stripe geom/virstor \
 	netgraph/atm netgraph/netflow \
+	net/lisp \
 	security/audit \
 	security/mac_biba security/mac_bsdextended security/mac_lomac \
 	security/mac_mls security/mac_partition \
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/conf/files freebsd-10.1.0-LISP/sys/conf/files
--- freebsd-10.1.0-RELEASE/sys/conf/files	2014-12-05 22:11:00.179243176 +0100
+++ freebsd-10.1.0-LISP/sys/conf/files	2014-12-14 13:47:08.813159060 +0100
@@ -3198,6 +3198,10 @@
 net/zlib.c			optional crypto | geom_uzip | ipsec | \
 					 mxge | netgraph_deflate | \
 					 ddb_ctf | gzio | geom_uncompress
+net/lisp/maptables.c		optional inet inet6 lisp
+net/lisp/mapsock.c		optional inet inet6 lisp
+net/lisp/lisp.c			optional inet inet6 lisp
+net/lisp/maptables_xpg.c	optional inet inet6 lisp
 net80211/ieee80211.c		optional wlan
 net80211/ieee80211_acl.c	optional wlan wlan_acl
 net80211/ieee80211_action.c	optional wlan
@@ -3399,6 +3403,7 @@
 netinet/libalias/alias_proxy.c	optional libalias inet | netgraph_nat inet
 netinet/libalias/alias_util.c	optional libalias inet | netgraph_nat inet
 netinet/libalias/alias_sctp.c	optional libalias inet | netgraph_nat inet
+netinet/lisp/ip_lisp.c		optional inet inet6 lisp
 netinet6/dest6.c		optional inet6
 netinet6/frag6.c		optional inet6
 netinet6/icmp6.c		optional inet6
@@ -3427,6 +3432,7 @@
 netinet6/scope6.c		optional inet6
 netinet6/sctp6_usrreq.c		optional inet6 sctp
 netinet6/udp6_usrreq.c		optional inet6
+netinet6/lisp6/ip6_lisp6.c	optional inet inet6 lisp
 netipsec/ipsec.c		optional ipsec inet | ipsec inet6
 netipsec/ipsec_input.c		optional ipsec inet | ipsec inet6
 netipsec/ipsec_mbuf.c		optional ipsec inet | ipsec inet6
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/conf/options freebsd-10.1.0-LISP/sys/conf/options
--- freebsd-10.1.0-RELEASE/sys/conf/options	2014-12-05 22:10:56.425367144 +0100
+++ freebsd-10.1.0-LISP/sys/conf/options	2014-12-14 13:47:08.817161060 +0100
@@ -407,6 +407,7 @@
 ETHER_SNAP		opt_ef.h
 INET			opt_inet.h
 INET6			opt_inet6.h
+LISP			opt_lisp.h
 IPDIVERT
 IPFILTER		opt_ipfilter.h
 IPFILTER_DEFAULT_BLOCK	opt_ipfilter.h
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/net/lisp/lisp.c freebsd-10.1.0-LISP/sys/net/lisp/lisp.c
--- freebsd-10.1.0-RELEASE/sys/net/lisp/lisp.c	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/net/lisp/lisp.c	2014-12-14 13:47:08.817161060 +0100
@@ -0,0 +1,712 @@
+/*- /usr/src/sys/net/lisp/lisp.c
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *
+ * $Id: lisp.c 177 2011-09-22 14:33:51Z ggx $
+ *
+ */
+
+#include "opt_inet.h"
+#include "opt_inet6.h"
+#include "opt_lisp.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/domain.h>
+#include <sys/eventhandler.h>
+#include <sys/jail.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/mac.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/proc.h>
+#include <sys/protosw.h>
+#include <sys/signalvar.h>
+#include <sys/socket.h>
+#include <sys/socketvar.h>
+#include <sys/sx.h>
+#include <sys/sysctl.h>
+#include <sys/syslog.h>
+
+#include <vm/uma.h>
+ 
+#include <net/if.h>
+#include <net/route.h>
+#include <net/netisr.h>
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/in_pcb.h>
+#include <netinet/in_var.h>
+#include <netinet/ip.h>
+#ifdef INET6
+#include <netinet/ip6.h>
+#endif
+#include <netinet/ip_icmp.h>
+#include <netinet/icmp_var.h>
+#include <netinet/ip_var.h>
+#ifdef INET6
+#include <netinet6/ip6_var.h>
+#endif
+
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+
+
+/* Sysctl Declaration
+ */
+
+SYSCTL_NODE(_net, OID_AUTO, lisp, CTLFLAG_RW, 0, "General LISP node");
+
+int lispdebug = 0;
+SYSCTL_INT(_net_lisp, OID_AUTO, debug, CTLFLAG_RW, &lispdebug, 0, 
+	   "Debug Mode LISP");
+
+
+extern struct mappingstats mappingstats;
+SYSCTL_STRUCT(_net_lisp, OID_AUTO, maptables, CTLFLAG_RW,
+	      &mappingstats, mappingstats, 
+	      "LISP Database and Cache stats (struct mappingstat, net/lisp/maptables.h)");
+
+
+int
+sysctl_matchkeyword(char *cp, struct keytab * keywords)
+{
+	struct keytab *kt = keywords;
+
+	while (kt->cptr && strcmp(kt->cptr, cp))
+		kt++;
+	return kt->seq;
+
+} /* sysctl_matchkeyword() */
+
+/* Sysctl for source port selection in LISP encapsulated packets
+ * - lispdata: Use LISP reserved port 4341 as source port.
+ * - shorthash: perform hash on the following field of the original 
+ *       packet <src IP, dst IP, Proto Number >.
+ * - longhash: perform hash on the following field of the original 
+ *       packet <src IP, dst IP, Proto Number, src Port, dst Port>. 
+ *       Actually there is no check if the protocol is UDP/TCP/SCTP
+ *       the bytes in the corresponding position are read and used
+ *       for the hash computation.
+ * - adaptivehash: perform a longhash for UDP/TCP/SCTP packets but short  *       hash for the rest.
+ */
+
+struct keytab srcport_keywords[] = {
+
+#define SRCPORT_LISPDATA      1
+        {"lispdata", SRCPORT_LISPDATA},
+
+#define SRCPORT_SHORTHASH     2
+        {"shorthash", SRCPORT_SHORTHASH},
+
+#define SRCPORT_LONGHASH      3
+        {"longhash", SRCPORT_LONGHASH},
+
+#define SRCPORT_ADAPTIVEHASH  4
+        {"adaptivehash", SRCPORT_ADAPTIVEHASH},
+
+	{0, 0}
+};
+
+static char lisp_src_port_string[LISPMAXSTRLEN] = "lispdata\0";
+static int  lispsrcport = SRCPORT_LISPDATA; 
+
+static int
+sysctl_net_lisp_srcport(SYSCTL_HANDLER_ARGS)
+{
+  
+        int error = 0;
+	int new = 0;
+	char tmpvalue[LISPMAXSTRLEN];
+
+	strcpy(tmpvalue, lisp_src_port_string);
+
+	error = sysctl_handle_string(oidp, lisp_src_port_string, 
+				     LISPMAXSTRLEN, req);
+	
+	if (error || req->newptr == NULL) 
+	        return (error);
+
+	if ( !(new = sysctl_matchkeyword(lisp_src_port_string, 
+					 srcport_keywords)) ) {
+
+	        strcpy(lisp_src_port_string, tmpvalue);
+  	        return(EINVAL);
+	 
+	};
+
+	lispsrcport = new;
+   
+         return (0);
+
+}  /* sysctl_net_lisp_srcport() */
+
+SYSCTL_PROC(_net_lisp, OID_AUTO, srcport, CTLTYPE_STRING | CTLFLAG_RW,
+	    0, 0, sysctl_net_lisp_srcport, "A", 
+	    "Algorithm used to set source port in LISP encapsulated packets");
+
+int lisphashseed = LISPDATA;
+SYSCTL_INT(_net_lisp, OID_AUTO, hashseed, CTLFLAG_RW, &lisphashseed, 0, 
+	   "Seed for Source Port selection Hash function (ignored if srcport is on <lispdata> mode");
+
+
+/* Sysctl for miss messages type:
+ * - ip: the miss message returns only the destination EID (IP address)
+ *       that generated the miss. This is the default setting.
+ * - header: the miss message returns the complete IP header of the 
+ *           packet that generated the miss. 
+ * - packet: the miss message returns the entire packet that generated 
+ *           the miss.
+ */
+
+struct keytab missmsg_keywords[] = {
+
+        {"eid", LISP_MISSMSG_EID},
+
+        {"header", LISP_MISSMSG_HEADER},
+
+        {"packet", LISP_MISSMSG_PACKET},
+
+	{0, 0}
+};
+
+
+static char lisp_miss_msg_string[LISPMAXSTRLEN] = "eid\0";
+int  lispmissmsg = LISP_MISSMSG_EID; 
+
+static int
+sysctl_net_lisp_missmsg(SYSCTL_HANDLER_ARGS)
+{
+  
+        int error = 0;
+	int new = 0;
+	char tmpvalue[LISPMAXSTRLEN];
+
+	strcpy(tmpvalue, lisp_miss_msg_string);
+
+	error = sysctl_handle_string(oidp, lisp_miss_msg_string, 
+				     LISPMAXSTRLEN, req);
+	
+	if (error || req->newptr == NULL) 
+	        return (error);
+
+	if ( !(new = sysctl_matchkeyword(lisp_miss_msg_string, 
+					 missmsg_keywords)) ) {
+
+	        strcpy(lisp_miss_msg_string, tmpvalue);
+  	        return(EINVAL);
+	 
+	};
+
+	lispmissmsg = new;
+   
+         return (0);
+
+}  /* sysctl_net_lisp_missmsg() */
+
+SYSCTL_PROC(_net_lisp, OID_AUTO, missmsg, CTLTYPE_STRING | CTLFLAG_RW,
+	    0, 0, sysctl_net_lisp_missmsg, "A", 
+	    "Type of message returned to the userspace upon cache miss");
+
+
+/* Sysctl for ETR policy:
+ * - standard (default): If an entry exists for the destination EID in the 
+ *         Database, then the packet is decapsulated and forwarded 
+ *         regardless if it exists an entry for the source EID into the 
+ *         cache. This is in accordance with the main specs
+ *         draft-ietf-lisp-06.txt.
+ * - notify: If an entry exists for the destination EID in the Database, 
+ *         then the packet is decapsulated and forwarded, 
+ *         if there is no entry in the Cache for the source EID a miss 
+ *         message is generate. 
+ * - secure: If an entry exists for the destination EID in the Database, 
+ *         then the packet is decapsulated only if an entry exists in the 
+ *         Cache for the source EID, otherwise a miss message is generated 
+ *	   and the packet is dropped.
+ *
+ * In all cases, if the entry in the cache exists, sanity checks are 
+ * performed.
+ */
+
+struct keytab ETR_keywords[] = {
+
+        {"standard", LISP_ETR_STANDARD},
+
+        {"notify", LISP_ETR_NOTIFY},
+
+        {"secure", LISP_ETR_SECURE},
+
+	{0, 0}
+};
+
+
+static char lisp_etr_string[LISPMAXSTRLEN] = "standard\0";
+int  lispetr = LISP_ETR_STANDARD; 
+
+static int
+sysctl_net_lisp_etr(SYSCTL_HANDLER_ARGS)
+{
+  
+        int error = 0;
+	int new = 0;
+	char tmpvalue[LISPMAXSTRLEN];
+
+	strcpy(tmpvalue, lisp_etr_string);
+
+	error = sysctl_handle_string(oidp, lisp_etr_string, 
+				     LISPMAXSTRLEN, req);
+	
+	if (error || req->newptr == NULL) 
+	        return (error);
+
+	if ( !(new = sysctl_matchkeyword(lisp_etr_string, 
+					 ETR_keywords)) ) {
+
+	        strcpy(lisp_etr_string, tmpvalue);
+  	        return(EINVAL);
+	 
+	};
+
+	lispetr = new;
+   
+         return (0);
+
+}  /* sysctl_net_lisp_etr() */
+
+SYSCTL_PROC(_net_lisp, OID_AUTO, etr, CTLTYPE_STRING | CTLFLAG_RW,
+	    0, 0, sysctl_net_lisp_etr, "A", 
+	    "ETR behavior for incoming LISP encapsulated packets");
+
+
+/*
+ * The following are hash functions developped by Bob Jenkins
+ * and publicly available at http://burtleburtle.net/bob/c/lookup3.c
+ * They are used to produce the hash value to put in the 
+ * source port number of the LISP encapsulation.
+ *
+ */
+
+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))
+
+/*
+-------------------------------------------------------------------------------
+mix -- mix 3 32-bit values reversibly.
+-------------------------------------------------------------------------------
+*/
+#define mix(a,b,c) \
+{ \
+  a -= c;  a ^= rot(c, 4);  c += b; \
+  b -= a;  b ^= rot(a, 6);  a += c; \
+  c -= b;  c ^= rot(b, 8);  b += a; \
+  a -= c;  a ^= rot(c,16);  c += b; \
+  b -= a;  b ^= rot(a,19);  a += c; \
+  c -= b;  c ^= rot(b, 4);  b += a; \
+}
+
+/*
+-------------------------------------------------------------------------------
+final -- final mixing of 3 32-bit values (a,b,c) into c
+-------------------------------------------------------------------------------
+*/
+#define final(a,b,c) \
+{ \
+  c ^= b; c -= rot(b,14); \
+  a ^= c; a -= rot(c,11); \
+  b ^= a; b -= rot(a,25); \
+  c ^= b; c -= rot(b,16); \
+  a ^= c; a -= rot(c,4);  \
+  b ^= a; b -= rot(a,14); \
+  c ^= b; c -= rot(b,24); \
+}
+
+/*
+--------------------------------------------------------------------
+ This works on all machines.  To be useful, it requires
+ -- that the key be an array of uint32_t's, and
+ -- that the length be the number of uint32_t's in the key
+--------------------------------------------------------------------
+*/
+static uint32_t hashword(
+const uint32_t *k,                   /* the key, an array of uint32_t values */
+size_t          length,               /* the length of the key, in uint32_ts */
+uint32_t        initval)         /* the previous hash, or an arbitrary value */
+{
+  uint32_t a,b,c;
+
+  /* Set up the internal state */
+  a = b = c = 0xdeadbeef + (((uint32_t)length)<<2) + initval;
+
+  /*------------------------------------------------- handle most of the key */
+  while (length > 3)
+  {
+    a += k[0];
+    b += k[1];
+    c += k[2];
+    mix(a,b,c);
+    length -= 3;
+    k += 3;
+  }
+
+  /*------------------------------------------- handle the last 3 uint32_t's */
+  switch(length)                     /* all the case statements fall through */
+  { 
+  case 3 : c+=k[2];
+  case 2 : b+=k[1];
+  case 1 : a+=k[0];
+    final(a,b,c);
+  case 0:     /* case 0: nothing left to add */
+    break;
+  }
+  /*------------------------------------------------------ report the result */
+  return c;
+}
+
+/* Routine to provide src port based on sysctl selection
+ */
+uint16_t 
+get_lisp_srcport( m )
+     struct mbuf ** m;
+{
+        uint32_t  keyarray[MAXKEYLEN];
+	uint32_t  hash;
+	uint16_t  port;
+	int  skipsize = 0; 
+	int keylen = 0;
+	struct ip * ip = NULL;
+	struct ip6_hdr * ip6 = NULL;
+
+	bzero(keyarray,(MAXKEYLEN*4));
+
+	if ( lispsrcport == SRCPORT_LISPDATA ) {
+	       /* This is the easy and fast case
+		*/
+
+                hash = LISPDATA;
+
+	} else {
+
+	       /* In the following do not care about network and host 
+		* byte order, we just want to have an hash value.
+		*/
+	        ip = mtod((*m), struct ip *);
+
+		switch (ip->ip_v) {
+	
+		case IPVERSION:
+
+		        keyarray[keylen++] = (uint32_t) ip->ip_src.s_addr;
+			keyarray[keylen++] = (uint32_t) ip->ip_dst.s_addr;
+			keyarray[keylen++] = ip->ip_p;
+			skipsize = sizeof(struct ip);
+
+			break;
+
+		case (IPV6_VERSION >> 4):
+
+		        ip6 = mtod((*m), struct ip6_hdr *);
+			bcopy( &(ip6->ip6_src), &keyarray[keylen],
+			      ( 2 * sizeof(struct in6_addr) )  );
+			keylen += 8; /* number of uint32_t for 2 IPv6 addr */
+			keyarray[keylen++] = ip6->ip6_nxt;
+			skipsize = sizeof(struct ip6_hdr);
+
+			break;
+
+		default:
+	  
+		        hash = LISPDATA;
+			/* GgX - Should generate an error??? 
+			 */
+		};
+
+		
+		switch ( lispsrcport ) {
+	  
+		case SRCPORT_ADAPTIVEHASH:
+
+		        if ( (keyarray[keylen-1] != IPPROTO_UDP) &&
+			     (keyarray[keylen-1] != IPPROTO_TCP) &&
+			     (keyarray[keylen-1] != IPPROTO_SCTP) )
+			       /* Last inserted item is the protocol number.
+				* If it is UDP, TCP, or SCTP fall through and 
+				* take the ports number. 
+				*/ 
+			        break;
+ 
+		case SRCPORT_LONGHASH:
+	 
+		       /* Be sure we can access port numbers*/
+		        (*m) = m_pullup((*m), skipsize + sizeof(uint32_t) );
+			if ( (*m) == NULL )
+			       /* GgX - Should handle error differently?
+				*/
+			        return(0);
+			  
+			keyarray[keylen++] = *(uint32_t *)(mtod((*m), caddr_t) + skipsize);
+
+			break;
+
+		default:
+		       /* This should really never happen!
+			*/
+		        hash = LISPDATA;
+
+		};
+		
+	        hash = hashword(keyarray, keylen, lisphashseed);
+
+	};
+
+
+       /* Reduce the hash on 16 bits */
+        port = *((uint16_t *)&hash) + *(((uint16_t *)&hash)+1);
+
+	return(port);
+
+}  /* get_lisp_srcport() */
+
+
+
+
+void
+m_copylisphdr(register struct mbuf **m, struct lispshimhdr * lisphdr)
+{
+	(*m) = m_pullup((*m), sizeof(struct lispshimhdr));
+
+	/* Previous check should guarantee that the LISP header is there
+	 * but for safety let's check again.
+	 */
+
+	if ( m ) {
+	   
+	        m_copydata((*m),0, sizeof(struct lispshimhdr),(caddr_t) lisphdr);
+
+	};
+
+}  /* m_copylisphdr() */
+
+
+
+struct mbuf *
+m_lisphdrprepend(struct mbuf *m, struct eidmap * remotemap, struct eidmap * localmap, struct locator * drloc, struct locator * srloc)
+/* 
+ * Prepends the lisp header to the mbuf m
+ */
+{
+        struct lispshimhdr * hdrptr = NULL; 
+  
+        M_PREPEND(m, sizeof(struct lispshimhdr), M_DONTWAIT);
+
+	if ( m ) {
+	   
+	        hdrptr = mtod(m, struct lispshimhdr *);
+		bzero( hdrptr, sizeof(struct lispshimhdr));
+	
+		/* Added destination dependent infos
+		 */
+
+		if ( drloc->rloc_metrix.rlocmtx.flags & RLOCF_TXNONCE ) {
+
+		       /* Set N bit and copy the nonce
+			*/
+		        hdrptr->Nbit = 1;
+			hdrptr->Nonce = drloc->rloc_metrix.rlocmtx.tx_nonce.nvalue;
+
+		};
+
+		if ( (localmap->mapping->map_flags & MAPF_VERSIONING) 
+		     &&  (remotemap->mapping->map_flags & MAPF_VERSIONING) ) {
+
+			       /* Copy the version numbers
+				*/
+			        hdrptr->Vbit = 1;
+			        hdrptr->Dvnum = remotemap->mapping->vnum;
+			        hdrptr->Svnum = localmap->mapping->vnum;
+
+		} else if (localmap->mapping->map_flags & MAPF_LOCBITS ) {
+			       /* Remote ETR does not support versioning
+				* If necessary put
+				* Locator Status Bits.
+   				*/
+				hdrptr->Lbit = 1;
+				hdrptr->LSbits = localmap->mapping->rlocs_statusbits;
+				
+		};			     
+
+	};
+
+
+	return m;
+
+}  /* m_lisphdrprepend() */
+
+
+int
+check_lisphdr(struct lispshimhdr * lisphdr, struct eidmap localmap, struct eidmap remotemap, struct locator * drloc, struct locator * srloc, int *why)
+{
+	struct map_addrinfo info;
+	int err = 0, msgtype = 0; 
+
+	*why = 0;
+
+	if  (lisphdr == NULL)  {
+	       
+#ifdef LISP_DEBUG
+		DEBUGLISP("[MAP_CHECK_RBITS] Received NULL pointer \n");
+#endif /* LISP_DEBUG */
+
+	        return(EINVAL);
+	};
+	  
+	bzero(&info, sizeof(info));	
+
+	if  (lisphdr->Nbit) {
+	       /* Received LISP Header contains a nonce.
+		*/
+
+	        if ( (remotemap.mapping) && (drloc) ) {
+		       /* LISP header contains nonce and we have 
+			* an entry in the cache. By now we just 
+			* copy the last received nonce
+			*/
+
+		        drloc->rloc_metrix.rlocmtx.flags |= RLOCF_RXNONCE;
+			drloc->rloc_metrix.rlocmtx.rx_nonce.nvalue = lisphdr->Nonce;
+		
+		};
+
+	} else if (lisphdr->Vbit)  {
+		          /* Versioning bit is set.
+		           */
+		   
+	        if ( MASKVNUM(ntohs(lisphdr->Dvnum)) &&
+		     (localmap.mapping->map_flags & MAPF_VERSIONING) &&
+		     ((lisphdr->Dvnum) != (localmap.mapping->vnum)) ) {
+	  
+		             if ( NEWERVNUM(ntohs(localmap.mapping->vnum),
+					    ntohs(lisphdr->Dvnum)) ) {
+			            /* Received version DST version number 
+				     * newer that the one stored in the DB.
+				     * Could not happen since the system is 
+				     * authoritative on the mapping
+				     */
+			            err = EINVAL;
+				    *why = ELISP_DSTVNUMINVAL;
+
+			     } else {
+			            /* Received version DST version number 
+				     * older that the one stored in the DB.
+				     * Notify Control Plane.
+				     */
+
+			             msgtype = MAPM_REMOTESTALE;
+
+			     }; 
+
+		} else if ( (remotemap.mapping) &&
+			    (remotemap.mapping->map_flags & MAPF_VERSIONING) &&  
+			    MASKVNUM(ntohs(lisphdr->Svnum)) &&
+			    ((lisphdr->Svnum) != (remotemap.mapping->vnum)) ) {
+
+		        if ( NEWERVNUM(ntohs(remotemap.mapping->vnum),
+				       ntohs(lisphdr->Svnum)) ) {
+			       /* Received version SRC version number 
+				* newer that the one stored in the 
+				* Cache.
+				*/
+
+			        msgtype = MAPM_LOCALSTALE;
+
+			} else {
+			       /* Received version SRC version number 
+				* older that the one stored in the 
+				* Cache.
+				*/
+		        
+			       /* This is too strict (causing drops), 
+				* but can work for early tests.
+				*/
+
+			        err = EINVAL;
+				*why = ELISP_SRCVNUMINVAL;
+
+			};
+
+		};
+			
+	};
+
+	
+	if (!msgtype) {
+
+	       if (lisphdr->Lbit) {
+	              /* Locator Status Bit is set and something changed 
+		       * notify otherwise do nothing.
+		       */
+
+		       if (  (remotemap.mapping) && (drloc) && 
+			     ((lisphdr->LSbits) != (remotemap.mapping->rlocs_statusbits)) ) {
+			       /* If there is an entry in the cache and 
+				* Received status bits have changed.
+				* Notify the Control Plane about this change.
+				* Changes are actually not sent. User space 
+				* processes interested in the change must 
+				* perform a GET.
+				*/
+
+			        msgtype = MAPM_LSBITS;
+
+		       };
+
+	       } else if (lisphdr->Ibit)  {
+		          /* Instance ID bit is set.
+			   * The Instance ID is just ignored right now.
+			   * This means ignoring also the short LS
+			   * bits.
+		           */
+	       };
+	       
+	};
+	  
+	if (msgtype) {
+
+	          info.mapi_addrs |= MAPA_EID;
+		  info.mapi_info[MAPX_EID] = (struct sockaddr_storage *)map_key(remotemap.mapping);
+		  map_notifymsg(msgtype, &info, NULL, NULL, 0, &err);
+
+	  };
+
+	  return err;
+
+}  /* check_lisphdr() */
+
+
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/net/lisp/lisp.h freebsd-10.1.0-LISP/sys/net/lisp/lisp.h
--- freebsd-10.1.0-RELEASE/sys/net/lisp/lisp.h	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/net/lisp/lisp.h	2014-12-14 13:47:08.817161060 +0100
@@ -0,0 +1,351 @@
+/*- /usr/src/sys/net/lisp/lisp.h
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *
+ * $Id: lisp.h 177 2011-09-22 14:33:51Z ggx $
+ *
+ */
+
+#ifndef _LISP_H_
+#define _LISP_H_
+
+#include <netinet/in.h>
+
+/* Switches for debugging
+ */
+#define LISP_DEBUG 1
+#define LISP_BASIC_DEBUG 1
+
+extern int lispmissmsg;
+extern int lispetr;
+
+extern int lispdebug;
+#define DEBUGLISP(x) \
+        if (lispdebug) {log(LOG_DEBUG,x);}
+
+
+/* General Settings
+ */
+
+#define LISPMAXSTRLEN        32
+
+
+/* Well-Known Port Numbers
+ */
+#define LISPDATA       4341  /* LISP Reserved port for Data encap/decap. 
+			      */
+#define LISPSIG        4342  /* LISP Reserved port for signaling. 
+			      * Message like Map-Request and Map-Reply 
+			      * use this port number.
+			      */
+#define MAXKEYLEN        10  /* Max size of the array containing the 
+			      * field to hash for src port selection.
+			      * This is the number of uint32_t.
+			      * The max length is in the case of extended 
+			      * hash (includes src and dst port number) for 
+			      * an IPv6 packet:
+			      * 8 uint32_t for the addresses
+			      * 1 uint32_t for the protocol number
+			      * 1 uint32_t for src & dst ports number
+			      *
+			      */
+
+
+/* LISP Stats
+ * This structure is used:
+ * /sys/netinet/lisp/ip_lisp.c        IPv4 Statistics
+ * /sys/netinet6/lisp6/ip6_lisp6.c    IPv6 Statistics
+ */
+struct	lispbasicstat {
+				/* input statistics: */
+	uint32_t ipackets;	  /* total input packets */
+	uint32_t ioafpackets;	  /* total input packet with a different 
+				   * AF family in the outer header packet 
+				   */
+	uint32_t ihdrops; 	  /* packet shorter than header */
+        uint32_t ibadencap;	  /* no local mapping present */
+	uint32_t ibadlen;	  /* data length larger than packet */
+        uint32_t ibadsrcvnum;     /* bad source version number */
+        uint32_t ibaddstvnum;     /* bad dst version number */
+
+				/* output statistics: */
+	uint32_t  opackets;		/* total output packets */
+        uint32_t  ooafpackets;	        /* total input packet with a different 
+					 * AF family in the inner packet 
+					 */
+        uint32_t  omissdrops;           /* Drops due to cache-miss. */
+        uint32_t  onorlocdrops;         /* Drops due to No suitable RLOC. */
+        uint32_t  osizedrops;           /* Drops due to MTU check. */
+        uint32_t  onobufdrops;          /* Drops due to no buffer space. */
+        uint32_t  odrops;               /* packet droped on output */
+};
+
+/*
+ * LISP Specific error condiition
+ * This MUST not be used outside the kernel LISP specific code.
+ */
+
+#ifdef _KERNEL
+#define ELISP_HDREINVAL     1
+#define ELISP_SRCVNUMINVAL  2
+#define ELISP_DSTVNUMINVAL   3
+#endif /* _KERNEL */
+
+/*
+ * LISP Packets data types and data structures.
+ */
+
+/* LISP Header in draft-ietf-lisp-08.txt
+ *
+ *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  L / |N|L|E|V|I|flags|                  Nonce/Map-Version            | 
+ *  I   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  S \ |                 Instance ID/Locator Reach Bits                |
+ *  P   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ */
+
+/* 
+ * Locator Status bits - Data type and Macros.
+ */ 
+
+typedef uint32_t  lsbits_type;   /* unsigned 32 bit for block 
+				   * manipulation. 
+				   */
+
+/* These two MUST be the same */
+#define MAXLBIT    32    /* Max Number of Locator Status Bits */
+#define MAXRLOCS   32    /* Max Number of RLOCs allowed in mapping */
+
+/* Locator Status bit insertion by shift operation 
+ */
+#if BYTE_ORDER == LITTLE_ENDIAN
+
+#define LSBITSHIFT(s) (1 << s)
+
+#endif
+
+#if BYTE_ORDER == BIG_ENDIAN
+
+#define LSBITSHIFT(s) (1 << s)
+
+#endif
+
+/*
+ * Versioning Bits
+ */
+
+struct vnum_subhdr {
+  
+        uint32_t pad:8,         /* padding */
+                 src_vnum:12,   /* Source Version Number in 
+				 * Network Byte Order
+			         */
+                 dst_vnum:12;   /* Destination Version Number in 
+				 * Network Byte Order
+				 */
+};
+
+#define MAXVNUM    4095
+#define WRAPVNUM   2047
+#define NULLVNUM   0
+
+#define MASKVNUM(z)    (0x00000FFF & z)
+ 
+/* The following returns 1 if x is newer the y.
+ * Note that NULL version number check is not done here and should be
+ * done by the user of the macro.
+ */
+#define NEWERVNUM(x,y) 			                \
+  ( ( (MASKVNUM(x) < WRAPVNUM) &&                       \
+      (MASKVNUM(x) < MASKVNUM(y)) &&                    \
+      (MASKVNUM(y) < MASKVNUM((x + WRAPVNUM)))) ? 1 :   \
+      ( ( (MASKVNUM(x) > WRAPVNUM) &&                   \
+	  ((MASKVNUM(x) < MASKVNUM(y)) ||               \
+	   (MASKVNUM(y) < MASKVNUM((x + WRAPVNUM))) ) ? 1 : 0 )) )	
+
+
+struct instanceid_subhdr {
+  
+        uint32_t ID:24,         /* Instance ID */
+                 shortlsb:8;    /* Short Loc-Stat-Bits 
+			         */
+
+};
+
+
+/* Nonce 24-bit to be kept in Network byte order 
+ */
+struct nonce_type { /* Nonce data type */
+
+      uint32_t pad:8,         /* padding */
+                nvalue:24;      /* nonce value */
+
+};      
+#define NONCEMASK 0x00FFFFFF
+#define MAXNONCE  16777216
+
+struct lispflags { /* LISP Header flags */
+      
+#if BYTE_ORDER == LITTLE_ENDIAN
+        uint32_t   rflag:3,            /* Reserved bits */
+                    I:1,                /* Instance ID Bit */
+                    V:1,                /* Versioning bit  */
+                    E:1,                /* Echo-Nonce bit */
+                    L:1,                /* Locator bit */ 
+                    N:1,                /* Nonce bit */
+                    pad:24;             /* padding */
+#endif
+
+#if BYTE_ORDER == BIG_ENDIAN
+        uint32_t    N:1,                /* Nonce bit       */
+                    L:1,                /* Locator bit     */ 
+                    E:1,                /* Echo-Nonce bit  */
+                    V:1,                /* Versioning bit  */
+                    I:1,                /* Instance ID Bit */
+                    rflag:3,            /* Reserved bits   */
+                    pad:24;             /* padding         */
+#endif
+
+};
+  
+struct lispshimhdr {                     /* LISP Specific shim header
+					  *
+					  * Flags V and N are mutually 
+					  * exclusive.
+					  * The max number of Loc Status
+					  * Bits is fixed to 32 (MAXLBIT).
+					  */		
+        union flags_nonce {
+    
+	        struct lispflags flags;      /* LISP Flags */
+
+	        struct nonce_type hdrnonce;  /* Nonce */  
+
+	        struct vnum_subhdr vnum;     /* String with Version Numbers
+					      */
+              
+	} fnv;
+
+  /* Useful shortcuts
+   */
+#define Nbit  fnv.flags.N
+#define Lbit  fnv.flags.L
+#define Ebit  fnv.flags.E
+#define Vbit  fnv.flags.V
+#define Ibit  fnv.flags.I
+#define Nonce fnv.hdrnonce.nvalue
+#define Svnum fnv.vnum.src_vnum
+#define Dvnum fnv.vnum.dst_vnum
+
+
+        union locstat_instance {
+
+                lsbits_type locbits;     /* String of Locator Status bits  
+					 */
+
+	        struct instanceid_subhdr ilsb;  /* Instance ID and short 
+						 * Loc-Stat-Bits
+						 */
+	} ils;
+
+  /* Useful shortcuts
+   */
+#define LSbits ils.locbits
+#define SLSbits ils.ilsb.locbits
+#define iID ils.ilsb.ID
+
+  /*#define Svnum lsv.vnum.src_vnum
+    #define Dvnum lsv.vnum.dst_vnum*/
+
+};
+
+
+/* 
+ * RLOC Address - 
+ * We union in_addr and in6_addr for RLOCs addresses, so that routines 
+ * manipulating RLOCs are unique, by using some macros that select 
+ * the correct type based on the address family
+ */
+union rloc_addr {                       /* RLOC address type union of 
+					 * in_addr and in6_addr. This allows 
+					 * flexible call to some maptable 
+					 * routines.
+					 */
+  struct in_addr  ipaddr;               /* Address IPv4 */
+  struct in6_addr ip6addr;              /* Address IPv6 */
+
+};  
+
+
+     
+/* 
+ * Usefull Macros
+ */
+
+/* Returns the size of the IP header depending on the address 
+ * Family
+ */
+#define SIZEOF_IPHDR(_af)				  		 \
+  ((_af == AF_INET) ? (sizeof(struct ip)) :                      \
+   ((_af == AF_INET6)?(sizeof(struct ip6_hdr)):	0))
+ 
+
+/* 
+ * Functions Prototype 
+ */
+#ifdef _KERNEL
+
+struct eidmap;
+struct locator;
+/* Data structure and function needed for other sysctl handlers.
+ */
+struct keytab {
+	char	*cptr;
+	int	seq;
+};
+
+int            sysctl_matchkeyword(char *, struct keytab *);
+
+void           m_copylisphdr(struct mbuf **, struct lispshimhdr *);
+
+struct mbuf *  m_lisphdrprepend(struct mbuf *, struct eidmap *, 
+				struct eidmap *, struct locator *, 
+				struct locator *);
+
+uint16_t       get_lisp_srcport(struct mbuf **);
+
+int            check_lisphdr( struct lispshimhdr *, struct eidmap,
+			      struct eidmap, struct locator *, 
+			      struct locator *, int *);
+
+#endif /* _KERNEL */
+
+#endif  /* _LISP_H_ */
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/net/lisp/mapsock.c freebsd-10.1.0-LISP/sys/net/lisp/mapsock.c
--- freebsd-10.1.0-RELEASE/sys/net/lisp/mapsock.c	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/net/lisp/mapsock.c	2014-12-14 13:58:52.849027930 +0100
@@ -0,0 +1,1312 @@
+/*- /usr/src/sys/net/lisp/mapsock.c
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ * Copyright (c) 2014        The hyLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *               Stefano Tribioli <sassospicco@hylisp.org>
+ *
+ */
+
+/*-
+ * Copyright (c) 1988, 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)rtsock.c	8.7 (Berkeley) 10/12/95
+ * $FreeBSD: src/sys/net/rtsock.c,v 1.123.2.7 2006/04/04 20:07:23 andre Exp $
+ */
+
+#include <sys/param.h>
+#include <sys/domain.h>
+#include <sys/kernel.h>
+#include <sys/jail.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/priv.h>
+#include <sys/proc.h>
+#include <sys/protosw.h>
+#include <sys/signalvar.h>
+#include <sys/socket.h>
+#include <sys/socketvar.h>
+#include <sys/sysctl.h>
+#include <sys/systm.h>
+
+#include "/usr/include/syslog.h"
+
+
+#include <net/if.h>
+#include <net/netisr.h>
+#include <net/raw_cb.h>
+#include <net/route.h>
+
+#include <netinet/in.h>
+#include <netinet/ip.h>
+#include <netinet/ip6.h>
+
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+
+static struct	sockaddr map_src = { 2, PF_ROUTE, };
+static struct	sockaddr_storage ss_ones_inet    = { sizeof(struct sockaddr_in),
+						     AF_INET, };
+static struct	sockaddr_storage ss_ones_inet6   = { sizeof(struct sockaddr_in6),
+						     AF_INET6, };
+ 
+
+static struct {
+  int	ip_count;	/* attached w/ AF_INET */
+  int	ip6_count;	/* attached w/ AF_INET6 */
+  int	ipx_count;	/* attached w/ AF_IPX */
+  int	any_count;	/* total attached */
+} map_cb;
+
+struct mtx mapsock_mtx;
+MTX_SYSINIT(mapsock, &mapsock_mtx, "mapsock map_cb lock", MTX_DEF);
+
+#define	MAPSOCK_LOCK()	mtx_lock(&mapsock_mtx)
+#define	MAPSOCK_UNLOCK()	mtx_unlock(&mapsock_mtx)
+#define	MAPSOCK_LOCK_ASSERT()	mtx_assert(&mapsock_mtx, MA_OWNED)
+  
+struct walkarg {
+	int	w_tmemsize;
+	int	w_op, w_arg;
+	caddr_t	w_tmem;
+	struct sysctl_req *w_req;
+};
+    
+
+static void	map_input(struct mbuf *m);
+static int	map_output(struct mbuf *m, struct socket *so);
+static void	map_dispatch(struct mbuf *, const struct sockaddr_storage *);
+static int	map_msg2(int type, struct map_addrinfo *mapinfo,
+			 caddr_t cp, struct walkarg *w);
+static int	map_xaddrs(caddr_t cp, caddr_t cplim, 
+			   struct map_addrinfo *mapinfo);
+static int	sysctl_dumpmapentry(struct radix_node *rn, void *vw);
+
+
+SYSCTL_NODE(_net, OID_AUTO, mapsock, CTLFLAG_RD, 0, "");
+
+static struct netisr_handler mapsock_nh = {
+        .nh_name = "mapsock",
+	.nh_handler = map_input,
+	.nh_proto = NETISR_MAPPING,
+	.nh_policy = NETISR_POLICY_SOURCE,
+};
+ 
+
+static int
+sysctl_mapsock_netisr_maxqlen(SYSCTL_HANDLER_ARGS)
+{
+        int error, qlimit;
+
+        netisr_getqlimit(&mapsock_nh, &qlimit);
+        error = sysctl_handle_int(oidp, &qlimit, 0, req);
+
+        if (error || !req->newptr)
+	        return (error);
+
+	if (qlimit < 1)
+	        return (EINVAL);
+
+	return (netisr_setqlimit(&mapsock_nh, qlimit));
+
+} /* sysctl_maptables_netisr_maxqlen() */
+
+SYSCTL_PROC(_net_mapsock, OID_AUTO, netisr_maxqlen, CTLTYPE_INT|CTLFLAG_RW,
+	    0, 0, sysctl_mapsock_netisr_maxqlen, "I",
+	    "maximum mapping socket dispatch queue length");
+
+
+static void
+map_init(void)
+{
+	int tmp;
+
+	if (TUNABLE_INT_FETCH("net.maptables.netisr_maxqlen", &tmp))
+	         mapsock_nh.nh_qlimit = tmp;
+
+	netisr_register(&mapsock_nh);
+	/* Init static structures */
+
+	memset( &(((struct sockaddr_in *)&ss_ones_inet)->sin_addr), 0xFF,
+		sizeof(struct in_addr));
+	memset( &(((struct sockaddr_in6 *)&ss_ones_inet6)->sin6_addr), 0xFF,
+		sizeof(struct in6_addr));
+
+} /* map_init() */
+
+SYSINIT(mapsock, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD, map_init, 0);
+
+static void
+map_input(struct mbuf *m)
+{
+  	struct sockproto map_proto;
+	unsigned short *family;
+	struct m_tag *tag;
+
+	map_proto.sp_family = PF_MAP;
+	tag = m_tag_find(m, PACKET_TAG_MAPSOCKFAM, NULL);
+	if (tag != NULL) {
+		family = (unsigned short *)(tag + 1);
+		map_proto.sp_protocol = *family;
+		m_tag_delete(m, tag);
+	} else
+		map_proto.sp_protocol = 0;
+
+	raw_input(m, &map_proto, &map_src);/*, &map_dst); from 7.0*/
+}
+
+/*
+ * It really doesn't make any sense at all for this code to share much
+ * with raw_usrreq.c, since its functionality is so restricted.  XXX
+ */
+static void
+map_abort(struct socket *so)
+{
+
+	raw_usrreqs.pru_abort(so);
+}
+
+static void
+map_close(struct socket *so) 
+{                                                                            
+
+        raw_usrreqs.pru_close(so);                                            
+} 
+
+static int
+map_attach(struct socket *so, int proto, struct thread *td)
+{
+	struct rawcb *rp;
+	int s, error;
+
+	KASSERT(so->so_pcb == NULL, ("map_attach: so_pcb != NULL"));    
+
+	/* XXX */
+	MALLOC(rp, struct rawcb *, sizeof *rp, M_PCB, M_WAITOK | M_ZERO);
+	if (rp == NULL)
+		return ENOBUFS;
+
+	/*
+	 * The splnet() is necessary to block protocols from sending
+	 * error notifications while
+	 * this PCB is extant but incompletely initialized.
+	 * Probably we should try to do more of this work beforehand and
+	 * eliminate the spl.
+	 */
+	s = splnet();
+	so->so_pcb = (caddr_t)rp;
+	error = raw_attach(so, proto);
+	rp = sotorawcb(so);
+	if (error) {
+		splx(s);
+		so->so_pcb = NULL;
+		free(rp, M_PCB);
+		return error;
+	}
+	MAPSOCK_LOCK();
+	switch(rp->rcb_proto.sp_protocol) {
+	case AF_INET:
+		map_cb.ip_count++;
+		break;
+	case AF_INET6:
+		map_cb.ip6_count++;
+		break;
+	case AF_IPX:
+		map_cb.ipx_count++;
+		break;
+	}
+	map_cb.any_count++;
+	MAPSOCK_UNLOCK();
+	soisconnected(so);
+	so->so_options |= SO_USELOOPBACK;
+	splx(s);
+	return 0;
+}
+
+
+static int
+map_bind(struct socket *so, struct sockaddr *nam, struct thread *td)
+{
+
+  return (raw_usrreqs.pru_bind(so, nam, td)); /* xxx just EINVAL */
+}
+
+static int
+map_connect(struct socket *so, struct sockaddr *nam, struct thread *td)
+{
+
+  return (raw_usrreqs.pru_connect(so, nam, td)); /* XXX just EINVAL */
+}
+
+
+static void
+map_detach(struct socket *so)
+{
+  	struct rawcb *rp = sotorawcb(so);
+
+	KASSERT(rp != NULL, ("map_detach: rp == NULL"));
+
+	MAPSOCK_LOCK();
+	switch(rp->rcb_proto.sp_protocol) {
+	case AF_INET:
+	        map_cb.ip_count--;
+		break;
+	case AF_INET6:
+	        map_cb.ip6_count--;
+		break;
+	}
+
+	map_cb.any_count--;
+	MAPSOCK_UNLOCK();
+	raw_usrreqs.pru_detach(so);
+
+}
+
+static int
+map_disconnect(struct socket *so)
+{
+
+	return (raw_usrreqs.pru_disconnect(so));
+}
+
+static int
+map_peeraddr(struct socket *so, struct sockaddr **nam)
+{
+
+	return (raw_usrreqs.pru_peeraddr(so, nam));
+}
+
+static int
+map_send(struct socket *so, int flags, struct mbuf *m, struct sockaddr *nam,
+	 struct mbuf *control, struct thread *td)
+{
+
+	return (raw_usrreqs.pru_send(so, flags, m, nam, control, td));
+}
+
+
+static int
+map_shutdown(struct socket *so)
+{
+
+	return (raw_usrreqs.pru_shutdown(so));
+}
+
+
+static int
+map_sockaddr(struct socket *so, struct sockaddr **nam)
+{
+
+	return (raw_usrreqs.pru_sockaddr(so, nam));
+}
+
+
+static struct pr_usrreqs map_usrreqs = {
+	.pru_abort =		map_abort,
+	.pru_attach =		map_attach,
+	.pru_bind =		map_bind,
+	.pru_connect =		map_connect,
+	.pru_detach =		map_detach,
+	.pru_disconnect =	map_disconnect,
+	.pru_peeraddr =		map_peeraddr,
+	.pru_send =		map_send,
+	.pru_shutdown =		map_shutdown,
+	.pru_sockaddr =		map_sockaddr,
+	.pru_close =            map_close,
+};
+
+
+static int
+map_output(struct mbuf *m, struct socket *so)
+{
+#define	sa_equal(a1, a2) (bcmp((a1), (a2), (a1)->ss_len) == 0)
+	struct map_msghdr *mapmsg = NULL;
+	struct mapentry *map = NULL;
+	struct radix_node_head *rnh;
+	struct map_addrinfo mapinfo;
+	int len, error = 0;
+
+#define senderr(e) { error = e; goto flush;}
+
+	if (m == NULL || ((m->m_len < sizeof(long)) &&
+		       (m = m_pullup(m, sizeof(long))) == NULL))
+		return (ENOBUFS);
+
+	if ((m->m_flags & M_PKTHDR) == 0)
+		panic("map_output");
+	len = m->m_pkthdr.len;
+
+	if (len < sizeof(*mapmsg) ||
+	    len != mtod(m, struct map_msghdr *)->map_msglen) {
+		mapinfo.mapi_info[MAPX_EID] = NULL;
+
+#ifdef LISP_DEBUG
+		DEBUGLISP("[MAP_OUTPUT] Message Length Missmatch \n");
+#endif /* LISP_DEBUG */
+
+		senderr(EINVAL);
+	}
+
+	R_Malloc(mapmsg, struct map_msghdr *, len);
+	if (mapmsg == NULL) {
+		mapinfo.mapi_info[MAPX_EID] = NULL;
+		senderr(ENOBUFS);
+	}
+
+	m_copydata(m, 0, len, (caddr_t)mapmsg);
+	if (mapmsg->map_version != MAPM_VERSION) {
+		mapinfo.mapi_info[MAPX_EID] = NULL;
+		senderr(EPROTONOSUPPORT);
+	}
+
+	mapmsg->map_pid = curproc->p_pid;
+	bzero(&mapinfo, sizeof(mapinfo));
+	mapinfo.mapi_addrs = mapmsg->map_addrs;
+	mapinfo.mapi_rloc_count = mapmsg->map_rloc_count;
+	mapinfo.mapi_versioning = mapmsg->map_versioning;
+	mapinfo.mapi_flags = mapmsg->map_flags;
+
+	/* GgX - map_xaddrs checks also the condition ss_family 
+	 * is either AF_INET or AF_INET6.
+	 * If the condition is true, EINVAL is returned.
+	 * Thus here no checks on ss_family are necessary.
+	 */
+	if (map_xaddrs((caddr_t)(mapmsg + 1), len + (caddr_t)mapmsg, &mapinfo)) {
+		 mapinfo.mapi_info[MAPX_EID] = NULL;
+
+#ifdef LISP_DEBUG
+		 DEBUGLISP("[MAP_OUTPUT] Message Addresses Not Valid \n");
+#endif /* LISP_DEBUG */
+
+		 senderr(EINVAL);
+	}
+
+	/* 
+	 *Force exact match lookup unless it is a GET 
+	 */	
+	if ( mapmsg->map_type != MAPM_GET
+	     && mapinfo.mapi_info[MAPX_EID] 
+	     && !(mapinfo.mapi_info[MAPX_EIDMASK])) {
+	       /* If no mask is provided point to a safe address
+		* with with a host length mask (i.e., /32 for IPv4
+		* and /128 for IPv6).
+		*/
+	  
+	        mapinfo.mapi_addrs |= MAPA_EIDMASK;
+	  
+		switch (mapinfo.mapi_info[MAPX_EID]->ss_family) {
+		case AF_INET:
+		        mapinfo.mapi_info[MAPX_EIDMASK] = &ss_ones_inet;
+			break; 
+			      
+		case AF_INET6:
+		        mapinfo.mapi_info[MAPX_EIDMASK] = &ss_ones_inet6;
+			break;
+		};
+
+	};
+
+	if ((mapinfo.mapi_rloc_count && (mapinfo.mapi_info[MAPX_RLOC] == NULL)) ||
+	    ((mapinfo.mapi_rloc_count == 0) && mapinfo.mapi_info[MAPX_RLOC]) ||
+	    ((mapinfo.mapi_flags & MAPF_NEGATIVE) && (mapinfo.mapi_rloc_count || mapinfo.mapi_info[MAPX_RLOC]))) {
+	       /* GgX - This is redundant but keep it by now */
+
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[MAP_OUTPUT] Badly Formatted RLOCs records! \n");
+#endif /* LISP_DEBUG */
+
+		senderr(EINVAL);
+	};
+	  
+	if (mapinfo.mapi_info[MAPX_EID] == NULL ) {
+
+#ifdef LISP_DEBUG
+	         DEBUGLISP("[MAP_OUTPUT] No EID Provided! \n");
+#endif /* LISP_DEBUG */
+
+	         senderr(EINVAL);
+	};
+
+       /* Checks if the eidmask is already in the radix 
+	*/
+//	if (mapinfo.mapi_info[MAPX_EIDMASK]) {
+//		struct radix_node *t;
+//
+//		MAPTABLES(rnh, mapinfo.mapi_info[MAPX_EID]->ss_family);
+//		if (rnh == NULL) 
+//			senderr(EAFNOSUPPORT);
+//		RADIX_NODE_HEAD_LOCK(rnh);
+//		t = rn_addmask_r((caddr_t) mapinfo.mapi_info[MAPX_EIDMASK], rnh, 0, 1);
+//		RADIX_NODE_HEAD_UNLOCK(rnh);
+//	
+//		if (t != NULL &&
+//		    bcmp((char *)(void *)mapinfo.mapi_info[MAPX_EIDMASK] + 1,
+//			 (char *)(void *)t->rn_key + 1,
+//			 ((struct sockaddr *)t->rn_key)->sa_len - 1) == 0)
+//		        mapinfo.mapi_info[MAPX_EIDMASK] = 
+//			  (struct sockaddr_storage *)t->rn_key;
+//		else
+//		        senderr(ENOBUFS);
+//	}
+  
+	/*
+	 * Verify that the caller has the appropriate privilege; MAPM_GET
+	 * is the only operation the non-superuser is allowed.
+	 */
+	if (mapmsg->map_type != MAPM_GET) {
+	        error = priv_check(curthread, PRIV_NET_ROUTE);
+		if (error)
+		        senderr(error);
+	}
+
+	switch (mapmsg->map_type) {
+	struct mapentry *saved_mapentry;
+
+	case MAPM_ADD:
+        
+		error = maprequest(MAPM_ADD, &mapinfo, &saved_mapentry);
+		
+		if (error == 0 && saved_mapentry) {
+		        MAP_LOCK(saved_mapentry);
+			MAP_REMREF(saved_mapentry);
+			MAP_UNLOCK(saved_mapentry);
+		};
+
+		break;
+
+	case MAPM_DELETE:
+
+	        saved_mapentry = NULL;
+		error = maprequest(MAPM_DELETE, &mapinfo, &saved_mapentry);
+		if (error == 0) {
+			MAP_LOCK(saved_mapentry);
+			map = saved_mapentry;
+			goto report;
+		}
+		break;
+		
+	case MAPM_GET:
+
+//		if (rnh == NULL) {
+	        MAPTABLES(rnh, mapinfo.mapi_info[MAPX_EID]->ss_family);
+			if (rnh == NULL)
+				senderr(EAFNOSUPPORT);
+//		}
+
+		RADIX_NODE_HEAD_LOCK(rnh);
+		map = (struct mapentry *) rnh->rnh_lookup(mapinfo.mapi_info[MAPX_EID], mapinfo.mapi_info[MAPX_EIDMASK], rnh);
+		if (map == NULL) {	/* XXX looks bogus */
+			RADIX_NODE_HEAD_UNLOCK(rnh);
+			senderr(ESRCH);
+		}
+
+
+		MAP_LOCK(map);
+		MAP_ADDREF(map);
+		RADIX_NODE_HEAD_UNLOCK(rnh);
+
+                 if (mapmsg->map_type != MAPM_GET && 
+                         (!map_mask(map) != !mapinfo.mapi_info[MAPX_EIDMASK])) {
+
+		         MAP_UNLOCK(map);
+                         senderr(ESRCH);
+
+		 }
+   
+		 switch(mapmsg->map_type) {
+ 
+		 case MAPM_GET:
+report:
+			MAP_LOCK_ASSERT(map);
+			mapinfo.mapi_info[MAPX_EID] = (struct sockaddr_storage *) map_key(map);
+			mapinfo.mapi_info[MAPX_EIDMASK] = (struct sockaddr_storage *) map_mask(map);
+			
+			mapinfo.mapi_rloc_count = map_rlocsnum(map);
+			if (mapinfo.mapi_rloc_count)
+			        mapinfo.mapi_info[MAPX_RLOC] = (struct sockaddr_storage *) map_rlocs(map);
+			/* GgX - This is not clean since actually map_rlocs(map)
+			 * points to a locator_chain struct that is the head
+			 * of the rlocs list. Yet this handled correctly
+			 * in map_msg2.
+			 */
+
+			if (map->map_flags & MAPF_VERSIONING) {
+			        mapinfo.mapi_versioning = ntohs(map->vnum);
+			};
+
+			len = map_msg2(mapmsg->map_type, &mapinfo, NULL, NULL);
+			if (len > mapmsg->map_msglen) {
+				struct map_msghdr *new_mapmsg;
+				R_Malloc(new_mapmsg, struct map_msghdr *, len);
+				if (new_mapmsg == NULL) {
+					MAP_UNLOCK(map);
+					senderr(ENOBUFS);
+				}
+				bcopy(mapmsg, new_mapmsg, mapmsg->map_msglen);
+				Free(mapmsg); 
+				mapmsg = new_mapmsg;
+			}
+
+			(void)map_msg2(mapmsg->map_type, &mapinfo, (caddr_t)mapmsg, NULL);
+			mapmsg->map_flags = map->map_flags;
+			mapmsg->map_addrs = mapinfo.mapi_addrs;
+			break;
+		}
+		MAP_UNLOCK(map);
+
+		break;
+	  
+	default:
+		senderr(EOPNOTSUPP);
+	}
+	
+flush:
+	if (mapmsg) {
+		if (error)
+			mapmsg->map_errno = error;
+		else
+			mapmsg->map_flags |= MAPF_DONE;
+	}
+	if (map)		/* XXX can this be true? */
+		MAPFREE(map);
+	
+	{
+	struct rawcb *rp = NULL;
+	/*
+	 * Check to see if we don't want our own messages.
+	 */
+	if ((so->so_options & SO_USELOOPBACK) == 0) {
+		if (map_cb.any_count <= 1) {
+		        if (mapmsg)
+				Free(mapmsg);
+			m_freem(m);
+			return (error);
+		}
+		/* There is another listener, so construct message */
+		rp = sotorawcb(so);
+	}
+	if (mapmsg) {
+		m_copyback(m, 0, mapmsg->map_msglen, (caddr_t)mapmsg);
+		if (m->m_pkthdr.len < mapmsg->map_msglen) {
+			m_freem(m);
+			m = NULL;
+		} else if (m->m_pkthdr.len > mapmsg->map_msglen)
+			m_adj(m, mapmsg->map_msglen - m->m_pkthdr.len);
+		Free(mapmsg);
+	}
+	if (m) {
+		if (rp) {
+			/*
+			 * XXX insure we don't get a copy by
+			 * invalidating our protocol
+			 */
+			unsigned short family = rp->rcb_proto.sp_family;
+			rp->rcb_proto.sp_family = 0;
+			map_dispatch(m, mapinfo.mapi_info[MAPX_EID]);
+			rp->rcb_proto.sp_family = family;
+		} else
+			map_dispatch(m, mapinfo.mapi_info[MAPX_EID]);
+	}
+	}
+	return (error);
+#undef	sa_equal
+
+} /* map_output */
+
+
+
+/*
+ * Extract the addresses of the passed sockaddrs.
+ * Do a little sanity checking so as to avoid bad memory references.
+ * This data is derived straight from userland.
+ */
+static int
+map_xaddrs(caddr_t cp, caddr_t cplim, struct map_addrinfo *mapinfo)
+{
+        struct sockaddr_storage *ss, *savedss;
+	int i, rlocnum;
+	int maskflag = 0;
+
+	for (i = 0; i < MAPX_MAX && cp < cplim; i++) {
+
+	  switch ((mapinfo->mapi_addrs & (1 << i))) {
+		
+	  case MAPA_EIDMASK:
+	        maskflag = 1;
+	       /* Remember that a mask has been provided and fall through.
+		*/
+
+	  case MAPA_EID:
+		ss = (struct sockaddr_storage *)cp;
+		/*
+		 * It won't fit.
+		 */
+		if (((cp + ss->ss_len) > cplim) || 
+		    ((ss->ss_family != AF_INET) && 
+		     (ss->ss_family != AF_INET6))) {
+
+#ifdef LISP_DEBUG
+		        DEBUGLISP("[MAP_XADDRS] EIDMASK not Valid! \n");
+#endif /* LISP_DEBUG */
+
+			return (EINVAL);
+
+		};
+
+		if (ss->ss_len == 0) {
+			return (EINVAL); 
+		}
+
+		/* accept it */
+		mapinfo->mapi_info[i] = ss;
+		cp += SS_SIZE(ss);
+
+		break;
+
+	  case MAPA_RLOC:
+	        if ((rlocnum = mapinfo->mapi_rloc_count) &&
+		    (mapinfo->mapi_flags & MAPF_NEGATIVE)) 
+		        return(EINVAL);
+	
+		savedss = (struct sockaddr_storage *)cp;
+		while (rlocnum--) {
+		          ss = (struct sockaddr_storage *)cp;
+			  /*
+			   * It won't fit.
+			   */
+			  if (((cp + ss->ss_len + sizeof(struct rloc_mtx)) > cplim) || 
+			      ((ss->ss_family != AF_INET) && 
+			       (ss->ss_family != AF_INET6))) {
+
+#ifdef LISP_DEBUG
+			          DEBUGLISP("[MAP_XADDRS] RLOC Addreess not Valid! \n");
+#endif /* LISP_DEBUG */
+
+ 			          return (EINVAL);
+
+			  };
+
+			  if (ss->ss_len == 0) {
+
+#ifdef LISP_DEBUG
+			          DEBUGLISP("[MAP_XADDRS] ss_len field equal 0! \n");
+#endif /* LISP_DEBUG */
+
+			          return (EINVAL); 			  
+			  };
+			  cp += SS_SIZE(ss);
+			  cp += sizeof(struct rloc_mtx); 
+			                     /* to count Priority, 
+					      * Weight, Flags, and
+					      * MTU;
+					      */
+		};
+		mapinfo->mapi_info[i] = savedss; 
+		                             /* store rloc chain head */
+		break;
+	  };
+
+	};
+
+	return (0);
+
+} /* map_xaddrs() */
+
+
+static struct mbuf *
+map_msg1(int type, struct map_addrinfo *mapinfo, struct mbuf ** mpkt)
+{
+	struct map_msghdr *mapm;
+	struct mbuf *m;
+	struct mbuf * mp = NULL; 
+	int i;
+	struct sockaddr_storage *ss;
+	int len, dlen;
+
+	switch (type) {
+	       /* Keep this, there can be other cases in the future 
+		*/
+
+	default:
+		len = sizeof(struct map_msghdr);
+	};
+
+	if (len > MCLBYTES)
+		panic("map_msg1");
+
+	m = m_gethdr(M_DONTWAIT, MT_DATA);
+	if (m && len > MHLEN) {
+		MCLGET(m, M_DONTWAIT);
+		if ((m->m_flags & M_EXT) == 0) {
+			m_free(m);
+			m = NULL;
+		}
+	}
+	if (m == NULL)
+		return (m);
+
+	m->m_pkthdr.len = m->m_len = len;
+	m->m_pkthdr.rcvif = NULL;
+	mapm = mtod(m, struct map_msghdr *);
+	bzero((caddr_t)mapm, len);
+	for (i = 0; i < MAPX_MAX; i++) {
+		if ((ss = mapinfo->mapi_info[i]) == NULL)
+			continue;
+		mapinfo->mapi_addrs |= (1 << i);
+		dlen = SS_SIZE(ss);
+		m_copyback(m, len, dlen, (caddr_t)ss);
+		len += dlen;
+	};
+	
+	/* Append other information if necessary
+	 */
+	switch (type) {
+
+	case MAPM_MISS_HEADER:
+
+	  if ( (*mpkt) == NULL) {
+	                m_freem(m);
+			return (NULL);
+		};
+	  
+		switch ((mapinfo->mapi_info[MAPX_EID])->ss_family) { 
+	  
+		case AF_INET:
+	                dlen = sizeof(struct ip);
+			(*mpkt) = m_pullup((*mpkt), dlen);
+			m_append(m, dlen, mtod((*mpkt), c_caddr_t));
+			len += dlen;
+			break;
+		
+		};
+#ifdef INET6
+		case AF_INET6:
+	                dlen = sizeof(struct ip6_hdr);
+			(*mpkt) = m_pullup((*mpkt), dlen);
+			m_append(m, dlen, mtod((*mpkt), c_caddr_t));
+			len += dlen;
+			break;
+#endif /* INET6 */	  
+
+		break;
+
+	case MAPM_MISS_PACKET:
+
+      	        mp = m_copypacket((*mpkt), M_DONTWAIT);
+
+	        if ( ((*mpkt) == NULL) || (mp == NULL) ){
+	                m_freem(m);
+			return (NULL);
+		};
+	  
+	        dlen = mp->m_pkthdr.len;
+		m_cat(m, mp);
+		m->m_pkthdr.len += dlen;
+		len += dlen;
+		break;
+
+	};
+
+
+	if (m->m_pkthdr.len != len) {
+		m_freem(m);
+		return (NULL);
+	}
+	mapm->map_msglen = len;
+	mapm->map_version = MAPM_VERSION;
+	mapm->map_type = type;
+	mapm->map_addrs = mapinfo->mapi_addrs;
+
+	return (m);
+
+} /* map_msg1() */
+
+
+static int
+map_msg2(int type, struct map_addrinfo *mapinfo, caddr_t cp, struct walkarg *w)
+{
+	int i;
+	int len, dlen, second_time = 0;
+	caddr_t cp0;
+	int rlocnum = 0;
+	struct rloc_mtx * rmtxptr = NULL;
+
+	mapinfo->mapi_addrs = 0;
+
+again:
+
+	len = sizeof(struct map_msghdr);
+
+	cp0 = cp;
+	if (cp0)
+		cp += len;
+	for (i = 0; i < MAPX_MAX; i++) {
+		struct sockaddr_storage *ss;
+		caddr_t * rlocmtx;
+		struct locator_chain * rlocp;
+
+		if ((ss = mapinfo->mapi_info[i]) == NULL)
+			continue;
+
+		mapinfo->mapi_addrs |= (1 << i);
+		
+		switch (1 << i) {
+		
+		case MAPA_EID:
+		case MAPA_EIDMASK:
+		        dlen = SS_SIZE(ss);
+			if (cp) {
+			       bcopy((caddr_t)ss, cp, (unsigned)dlen);
+			       cp += dlen;
+			}
+			len += dlen;
+			break;
+
+		case MAPA_RLOC:
+	                rlocnum = mapinfo->mapi_rloc_count;
+		        rlocp = (struct locator_chain *) mapinfo->mapi_info[i];
+ 		        while (rlocnum--) {
+		                ss = (struct sockaddr_storage *) rlocp->rloc.rloc_addr;
+				dlen = SS_SIZE(ss);
+				if (cp) {
+			                bcopy((caddr_t)ss, cp, (unsigned)dlen);
+					cp += dlen;
+				}
+				len += dlen;
+
+				/* Metrics */
+				rlocmtx = (caddr_t *) &rlocp->rloc.rloc_metrix.rlocmtx;
+				dlen = sizeof(struct rloc_mtx);
+				if (cp) {
+			                bcopy(rlocmtx, cp, (unsigned)dlen);
+				       /* Convert nonces in host byte order
+					*/
+					rmtxptr = (struct rloc_mtx*)cp;
+					rmtxptr->tx_nonce.nvalue = ntohl(((struct rloc_mtx *)rlocmtx)->tx_nonce.nvalue) >> 8;
+					rmtxptr->rx_nonce.nvalue = ntohl(((struct rloc_mtx *)rlocmtx)->rx_nonce.nvalue) >> 8;
+					cp += dlen;
+				}
+				len += dlen;
+
+				rlocp = rlocp->next;
+
+			};
+			break;
+		};
+
+	}
+	len = ALIGN(len);
+	if (cp == NULL && w != NULL && !second_time) {
+		struct walkarg *rw = w;
+
+		if (rw->w_req) {
+			if (rw->w_tmemsize < len) {
+				if (rw->w_tmem)
+					free(rw->w_tmem, M_RTABLE);
+				rw->w_tmem = (caddr_t)
+					malloc(len, M_RTABLE, M_NOWAIT);
+				if (rw->w_tmem)
+					rw->w_tmemsize = len;
+			}
+			if (rw->w_tmem) {
+				cp = rw->w_tmem;
+				second_time = 1;
+				goto again;
+			}
+		}
+	}
+
+	if (cp) {
+
+		struct map_msghdr *mapmsg = (struct map_msghdr *)cp0;
+
+		mapmsg->map_version = MAPM_VERSION;
+		mapmsg->map_type = type;
+		mapmsg->map_msglen = len;
+		mapmsg->map_rloc_count = mapinfo->mapi_rloc_count;
+		mapmsg->map_versioning = mapinfo->mapi_versioning;
+
+	};
+
+	return (len);
+
+} /* map_msg2 */
+
+
+void
+map_notifymsg(int type, struct map_addrinfo *mapinfo, struct mapentry *mapping, struct mbuf ** mpkt, int flags, int * error)
+/*
+ * This routine is called to generate a message from the mapping
+ * socket indicating that something occured or a map lookup failed.
+ * In case of MAPM_MISS type the mapping pointer is ignored.
+ * In case of MAPM_EXPIRED type the mpkt pointer is ignored.
+ */
+{
+	struct map_msghdr *mapm;
+	struct mbuf *m;
+	struct sockaddr_storage *ss = mapinfo->mapi_info[MAPX_EID];
+	struct map_addrinfo newmapinfo;
+	int len = 0;
+
+	if (map_cb.any_count == 0) 
+		return;
+
+	switch (type) {
+
+	case MAPM_MISS:
+	  
+	        switch (lispmissmsg) {
+	    
+		case LISP_MISSMSG_PACKET:
+
+		  if ( (*mpkt) == NULL ) {
+		                 (*error) = ENOATTR;
+				 return;
+			};
+
+			type = MAPM_MISS_PACKET;
+
+			break;
+
+		case LISP_MISSMSG_HEADER:
+
+		  if ( (*mpkt) == NULL ) {
+		                (*error) = ENOATTR;
+				return;
+			};
+
+			type = MAPM_MISS_HEADER;
+
+			break;
+
+		case LISP_MISSMSG_EID: 
+		default:
+
+	                type = MAPM_MISS_EID;
+
+		};
+
+		m = map_msg1(type, mapinfo, mpkt);
+
+		break;
+
+	case MAPM_DELETE:
+	      
+	        if (mapping == NULL) {
+		        (*error) = ENOATTR;
+			return;
+		};
+
+		bzero(&newmapinfo, sizeof(newmapinfo));
+		
+		newmapinfo.mapi_addrs |= MAPA_EID;
+                newmapinfo.mapi_info[MAPX_EID] = (struct sockaddr_storage *) map_key(mapping);
+		newmapinfo.mapi_addrs |= MAPA_EIDMASK;
+                newmapinfo.mapi_info[MAPX_EIDMASK] = (struct sockaddr_storage *) map_mask(mapping);
+
+                newmapinfo.mapi_rloc_count = map_rlocsnum(mapping);
+
+                if (newmapinfo.mapi_rloc_count) {
+		       newmapinfo.mapi_addrs |= MAPA_RLOC;
+		       newmapinfo.mapi_info[MAPX_RLOC] = (struct sockaddr_storage *) map_rlocs(mapping);
+                        /* This is not clean since actually map_rlocs(map)
+			 * points to a locator_chain struct that is the head
+			 * of the rlocs list. Yet this handled correctly
+			 * in map_msg2.
+			 */
+		};
+
+                if (mapping->map_flags & MAPF_VERSIONING) 
+		        newmapinfo.mapi_versioning = ntohs(mapping->vnum);
+		
+
+		len = map_msg2(type, &newmapinfo, NULL, NULL);
+
+		if (len > MCLBYTES)
+		       panic("map_notifymsg");
+
+		m = m_gethdr(M_DONTWAIT, MT_DATA);
+		if (m && len > MHLEN) {
+		        MCLGET(m, M_DONTWAIT);
+			if ((m->m_flags & M_EXT) == 0) {
+			        m_free(m);
+				m = NULL;
+			};
+		};
+
+		if (m == NULL) {
+		        (*error) = ENOBUFS;
+		        return;
+		};
+
+		R_Malloc(mapm, struct map_msghdr *, len);
+
+		if (mapm == NULL) {
+		        m_free(m);
+		        (*error) = ENOBUFS;
+		        return;
+		};
+
+		(void)map_msg2(type, &newmapinfo, (caddr_t)mapm, NULL);
+
+                mapm->map_flags = mapping->map_flags;
+                mapm->map_addrs = newmapinfo.mapi_addrs;
+
+		if (mapm) {
+		  
+		        m_copyback(m, 0, mapm->map_msglen, (caddr_t)mapm);
+			
+			if (m->m_pkthdr.len < mapm->map_msglen) {
+			        m_freem(m);
+				m = NULL;
+			} else if (m->m_pkthdr.len > mapm->map_msglen)
+			        m_adj(m, mapm->map_msglen - m->m_pkthdr.len);
+			
+			Free(mapm);
+		
+		};
+
+		break;
+
+	default:
+
+ 	        m = NULL; 
+
+	};
+
+	if (m == NULL)
+		return;
+
+	mapm = mtod(m, struct map_msghdr *);
+	mapm->map_flags |= (MAPF_DONE | flags);
+	mapm->map_errno = (*error);
+	map_dispatch(m, ss);
+
+}  /* map_notifymsg() */
+
+
+static void
+map_dispatch(struct mbuf *m, const struct sockaddr_storage *ss)
+{
+	struct m_tag *tag;
+
+	/*
+	 * Preserve the family from the sockaddr, if any, in an m_tag for
+	 * use when injecting the mbuf into the routing socket buffer from
+	 * the netisr.
+	 */
+	if (ss != NULL) {
+		tag = m_tag_get(PACKET_TAG_MAPSOCKFAM, sizeof(unsigned short),
+		    M_NOWAIT);
+		if (tag == NULL) {
+			m_freem(m);
+			return;
+		}
+		*(unsigned short *)(tag + 1) = ss->ss_family;
+		m_tag_prepend(m, tag);
+	}
+	netisr_queue(NETISR_MAPPING, m); /* mbuf is free'd on failure. */
+}
+
+
+
+/*
+ * This is used in dumping the kernel table via sysctl().
+ */
+static int
+sysctl_dumpmapentry(struct radix_node *rn, void *vw)
+{
+	struct walkarg *w = vw;
+	struct mapentry *map = (struct mapentry *)rn;
+	int error = 0, size;
+	struct map_addrinfo info;
+
+	if (w->w_op == NET_MAPTBL_FLAGS && !(map->map_flags & w->w_arg))
+		return 0;
+
+	bzero((caddr_t)&info, sizeof(info));
+
+	info.mapi_addrs = MAPA_EID;
+
+	info.mapi_info[MAPX_EID] = (struct sockaddr_storage *) map_key(map);
+
+	if ( map_mask(map) != NULL ) {
+	        info.mapi_addrs |= MAPA_EIDMASK;
+		info.mapi_info[MAPX_EIDMASK] = (struct sockaddr_storage *) map_mask(map);
+	};
+
+	info.mapi_rloc_count = map_rlocsnum(map);
+	if (info.mapi_rloc_count) {
+	        info.mapi_addrs |= MAPA_RLOC;
+	        info.mapi_info[MAPX_RLOC] = (struct sockaddr_storage *) map_rlocs(map);
+	};
+
+	size = map_msg2(MAPM_GET, &info, NULL, w);
+	if (w->w_req && w->w_tmem) {
+		struct map_msghdr *mapmsg = (struct map_msghdr *)w->w_tmem;
+
+		mapmsg->map_flags = map->map_flags;
+		mapmsg->map_errno = mapmsg->map_pid = mapmsg->map_seq = 0;
+		mapmsg->map_addrs = info.mapi_addrs;
+		error = SYSCTL_OUT(w->w_req, (caddr_t)mapmsg, size);
+		return (error);
+	}
+
+	return (error);
+
+}  /* sysctl_dumpmapentry() */
+
+static int
+sysctl_mapsock(SYSCTL_HANDLER_ARGS)
+{
+  	int	*name = (int *)arg1;
+	u_int	namelen = arg2;
+	struct radix_node_head *rnh;
+	int	i, lim, error = EINVAL;
+
+	u_char	af;
+	struct	walkarg w;
+	
+	name++;
+	namelen--;
+
+	if (req->newptr)
+		return (EPERM);
+
+	if (namelen != 3)
+		return ((namelen < 3) ? EISDIR : ENOTDIR);
+
+	af = name[0];
+	if (af > AF_MAX) {
+
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[SYSCTL_MAPSOCK] AF out of range! \n");
+#endif /* LISP_DEBUG */
+
+		return (EINVAL);
+	};
+
+	bzero(&w, sizeof(w));
+	w.w_op = name[1];
+	w.w_arg = name[2];
+	w.w_req = req;
+	
+	error = sysctl_wire_old_buffer(req, 0);
+	if (error)
+		return (error);
+
+	switch (w.w_op) {
+
+	case NET_MAPTBL_DUMP:
+	case NET_MAPTBL_FLAGS:
+	  	if (af == 0) {			/* dump all tables */
+			i = 0;
+			lim = AF_MAX;
+		} else				/* dump only one table */
+			i = lim = af;
+		
+	          for (error = 0; error == 0 && i < lim; i++) {
+		  MAPTABLES(rnh,i);
+		  if ( rnh != NULL) {
+				RADIX_NODE_HEAD_LOCK(rnh); 
+			    	error = rnh->rnh_walktree(rnh,
+				    sysctl_dumpmapentry, &w);
+				RADIX_NODE_HEAD_UNLOCK(rnh);
+			} else if (af != 0)
+				error = EAFNOSUPPORT;
+		
+		  };
+		break;
+	}
+
+	if (w.w_tmem)
+	        free(w.w_tmem, M_RTABLE);
+
+	return (error);
+
+}  /* sysctl_mapsock() */
+						
+SYSCTL_NODE(_net, PF_MAP, maptbl, CTLFLAG_RD, sysctl_mapsock, "");
+
+/*
+ * Definitions of protocols supported in the MAP domain.
+ */
+
+static struct domain mapsockdomain;		
+						
+static struct protosw mapsw[] = {
+{
+	.pr_type =		SOCK_RAW,
+	.pr_domain =		&mapsockdomain,
+	.pr_flags =		PR_ATOMIC|PR_ADDR,
+	.pr_output =		map_output,
+	.pr_ctlinput =		raw_ctlinput,
+	.pr_init =		raw_init,
+	.pr_usrreqs =		&map_usrreqs
+}
+};
+
+static struct domain mapsockdomain = {
+	.dom_family =		PF_MAP,
+	.dom_name =		"mapsock",
+	.dom_protosw =		mapsw,
+	.dom_protoswNPROTOSW =	&mapsw[sizeof(mapsw)/sizeof(mapsw[0])],
+	.dom_maxrtkey =         sizeof(struct sockaddr_storage) 
+	                        /* GgX - To manage both IPv4 and IPv6 key 
+				 */
+};
+
+DOMAIN_SET(mapsock);
+
+
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/net/lisp/maptables.c freebsd-10.1.0-LISP/sys/net/lisp/maptables.c
--- freebsd-10.1.0-RELEASE/sys/net/lisp/maptables.c	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/net/lisp/maptables.c	2014-12-14 13:47:08.817161060 +0100
@@ -0,0 +1,1321 @@
+/*- /usr/src/sys/net/lisp/maptables.c
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *
+ * $Id: maptables.c 176 2011-09-22 14:06:30Z ggx $
+ *
+ */
+
+/* Copyright (c) 1980, 1986, 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)route.c	8.3.1.1 (Berkeley) 2/23/95
+ * $FreeBSD: src/sys/net/route.c,v 1.109.2.2 2005/09/26 14:59:12 glebius Exp $
+ */
+
+#include "opt_inet.h"
+#include "opt_mrouting.h"
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/socket.h>
+#include <sys/domain.h>
+#include <sys/kernel.h>
+#include <sys/libkern.h>
+#include <sys/syslog.h>
+
+#include <net/if.h>
+
+#include <vm/uma.h>
+
+#include <net/route.h>
+
+#include <netinet/in.h>
+#include <netinet/in_var.h>
+#include <netinet/ip_var.h>
+
+#include <netinet6/in6_var.h>
+#include <netinet/ip6.h>
+#include <netinet6/ip6_var.h>
+
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+#include <net/lisp/maptables_xpg.h>
+
+struct mappingstats mappingstats;
+
+struct radix_node_head *map_tables[MAX_TABLES];
+
+static int  maptrash;	/* mappings not in table but not freed */
+
+static int  map_fix_local_rlocs(struct locator_chain *);
+
+static void map_maskedcopy(struct sockaddr_storage *,  
+			   struct sockaddr_storage *, 
+			   struct sockaddr_storage *);
+
+static int map_setrlocs(caddr_t *, struct locator_chain **, int, 
+			lsbits_type *, int);
+static int map_insertrloc(struct locator_chain **, struct sockaddr_storage *,
+			  struct rloc_mtx *);
+
+static void  FreeRloc(struct locator_chain * rlocchain);
+
+static void map_copylsbit(struct locator_chain *, lsbits_type *);
+
+static struct mapentry * maplookup(struct sockaddr *, int);
+
+/*
+ * Convert a 'struct radix_node *' to a 'struct mapentry *'.
+ * The operation can be done safely (in this code) because a
+ * 'struct mapentry' starts with two 'struct radix_node''s, the first
+ * one representing leaf nodes in the routing tree, which is
+ * what the code in radix.c passes us as a 'struct radix_node'.
+ *
+ * But because there are a lot of assumptions in this conversion,
+ * do not cast explicitly, but always use the macro below.
+ */
+#define RNTOMAP(p)	((struct mapentry *)(p))
+ 
+static uma_zone_t mapzone;		/* Mapping table UMA zone. */
+
+static void
+maptables_init(void)
+/* 
+ * This init both maptables for IPv4 and IPv6 EIDs 
+ */
+{
+ 
+	mapzone = uma_zcreate("mapentry", sizeof(struct mapentry), NULL, NULL,
+	    NULL, NULL, UMA_ALIGN_PTR, 0);
+
+	if (rn_inithead((void**)(void *) &map_tables[IPv4_EIDs_TABLE], 0) == 0){
+	        log(LOG_INFO,"WARNING!!! IPv4 MapTable Init KO \n");
+	} 
+	else {
+	  	/* Initialize Expunge Timer */
+	        callout_init(&maptable_xpg_timer[IPv4_EIDs_TABLE], 
+			     CALLOUT_MPSAFE);
+		
+		maptable_xpgto_args[IPv4_EIDs_TABLE].rnh = map_tables[IPv4_EIDs_TABLE];
+		maptable_xpgto_args[IPv4_EIDs_TABLE].af_family = AF_INET;
+
+		lisp_cache_xpg_to((void *) &maptable_xpgto_args[IPv4_EIDs_TABLE]);
+
+	        log(LOG_INFO,"IPv4 MapTable Init OK \n");
+	};
+      
+        if (rn_inithead((void**)(void *)&map_tables[IPv6_EIDs_TABLE], 0) == 0){
+	        log(LOG_INFO,"WARNING!!! IPv6 MapTable Init KO \n");
+	}
+	else {
+	  	/* Initialize Expunge Timer */
+	        callout_init(&maptable_xpg_timer[IPv6_EIDs_TABLE], 
+			     CALLOUT_MPSAFE);
+
+		maptable_xpgto_args[IPv6_EIDs_TABLE].rnh = map_tables[IPv6_EIDs_TABLE];
+		maptable_xpgto_args[IPv6_EIDs_TABLE].af_family = AF_INET6;
+
+		lisp_cache_xpg_to((void *) &maptable_xpgto_args[IPv6_EIDs_TABLE]);
+
+	        log(LOG_INFO,"IPv6 MapTable Init OK \n");
+	};
+
+
+} /* maptables_init() */
+
+/*
+ * Packet Mapping routines.
+ */
+
+static int 
+map_fix_local_rlocs(struct locator_chain * lcptr)
+{
+        int error = EINVAL;
+	struct sockaddr_in *rloc_inet = NULL;
+	struct sockaddr_in6 *rloc_inet6 = NULL;
+	struct in_ifaddr *ia = NULL;
+	struct in6_ifaddr *ia6 = NULL;
+
+	while ( lcptr ) {
+	       /* Scan the chain checking if the RLOC is the address 
+		* of a local interface. 
+		*/ 
+
+	        switch (lcptr->rloc.rloc_addr->ss_family) {
+      
+			case AF_INET:
+	
+			        rloc_inet = (struct sockaddr_in *) lcptr->rloc.rloc_addr;
+				INADDR_TO_IFADDR(rloc_inet->sin_addr, ia); 
+
+				/*
+				 * If the address matches, set RLOCF_LIF 
+				 * flag and MTU.
+				 */
+				if ((ia != NULL) &&
+				    (IA_SIN(ia)->sin_addr.s_addr == rloc_inet->sin_addr.s_addr)) {
+				        lcptr->rloc.rloc_metrix.rlocmtx.flags |= RLOCF_LIF;
+					lcptr->rloc.rloc_metrix.rlocmtx.mtu = (ia->ia_ifp)->if_mtu;
+					
+					error = 0;
+  
+				};
+ 
+			  
+				break;
+		    
+			case AF_INET6:
+
+			        rloc_inet6 = (struct sockaddr_in6 *) lcptr->rloc.rloc_addr;
+
+			
+				ia6 = (struct in6_ifaddr *)ifa_ifwithaddr((struct sockaddr *)(rloc_inet6));
+
+
+
+				/*
+				 * If the address matches, set RLOCF_LIF 
+				 * flag and MTU.
+				 */
+				if ((ia6 != NULL) &&
+				    (IN6_ARE_ADDR_EQUAL(&ia6->ia_addr.sin6_addr,
+							&rloc_inet6->sin6_addr))) {
+
+				        lcptr->rloc.rloc_metrix.rlocmtx.flags |= RLOCF_LIF;
+					lcptr->rloc.rloc_metrix.rlocmtx.mtu = (ia6->ia_ifp)->if_mtu;
+					
+					error = 0;
+  
+				};
+				break;
+
+		};
+
+	        lcptr = lcptr->next;
+
+	};
+
+#ifdef LISP_DEBUG
+	if (error) {
+	        DEBUGLISP("[MAP_FIX_LOCAL_RLOC] No local IF RLOCs Provided for local mapping! \n");
+	};
+#endif /* LISP_DEBUG */
+
+
+	return (error);
+
+}  /* map_fix_local_rloc() */
+
+
+
+struct locator *
+map_findrloc(struct mapentry * mapping, struct sockaddr_storage * rlocaddr)
+/* 
+ * Scan the RLOC chain for a matching RLOC
+ * returns a pointer to the locator on success NULL otherwise
+ * The caller should make sure that no changes that can 
+ * invalid the pointer can arrive beofre its use.
+ */
+{
+        struct locator_chain * lc = mapping->rlocs;
+	int match = 0;
+
+	while ( lc && !match ) {
+	       /* Scan the chain looking for matching rloc 
+		*/ 
+
+	        if (lc->rloc.rloc_addr->ss_family == rlocaddr->ss_family) {
+
+		        switch (rlocaddr->ss_family) {
+      
+			case AF_INET:
+
+	 		       if (!bcmp( &((struct sockaddr_in *)lc->rloc.rloc_addr)->sin_addr, &((struct sockaddr_in *)rlocaddr)->sin_addr, sizeof(struct in_addr))) 
+	
+				       match = 1;
+
+				break;
+		    
+			case AF_INET6:
+			        if ( !bcmp( &((struct sockaddr_in6 *)lc->rloc.rloc_addr)->sin6_addr, &((struct sockaddr_in6 *)rlocaddr)->sin6_addr, sizeof(struct in6_addr)))	
+				        match = 1;
+				break;
+
+			};
+
+		};
+
+		if (!match)
+		        lc = lc->next;
+
+	};
+
+	if (match) {
+	  
+	        return(&lc->rloc); 
+
+	} else {
+
+	        return(NULL);
+
+	};
+
+}  /* map_findrloc() */
+ 
+
+int 
+map_select_srcrloc(struct mapentry * dbmap, struct locator * drloc,  struct locator ** srloc)
+/* Selection of the source RLOC depends on the 
+ * outgoing interface and the AF of the destination RLOC.
+ */
+{
+        struct route_in6 ip6_rt;
+	struct sockaddr_storage out_ifa;
+        struct in_ifaddr * ia = NULL;
+	struct ifnet *ifp = NULL;
+	struct rtentry *rt = NULL;
+	struct sockaddr_in6 ip6_dst;
+	
+	bzero( &out_ifa, sizeof(struct sockaddr_storage) );
+
+	switch (drloc->rloc_addr->ss_family) {
+
+	case AF_INET:
+
+	        ia = ip_rtaddr( *((struct in_addr *) 
+				  &(((struct sockaddr_in *)drloc->rloc_addr)->sin_addr)), 0);
+	       /* XXX - 0 is the default FIB
+		*/
+
+		if (ia == NULL) {  /* No output interface == no route */
+		  
+		        return ENOATTR;
+	  
+		};
+
+                out_ifa.ss_family = AF_INET;
+		out_ifa.ss_len = sizeof(struct sockaddr_in);
+		((struct sockaddr_in *)&out_ifa)->sin_addr =  IA_SIN(ia)->sin_addr;
+
+		break;
+
+	case AF_INET6:
+	  
+	        bzero( &ip6_rt, sizeof(struct route_in6) );
+
+		bzero( &ip6_dst, sizeof(struct sockaddr_in6) );
+		ip6_dst.sin6_len = sizeof(struct sockaddr_in6);
+		ip6_dst.sin6_family = AF_INET6;
+		ip6_dst.sin6_addr = *((struct in6_addr *)&(((struct sockaddr_in6 *)drloc->rloc_addr)->sin6_addr));
+
+		if ((in6_selectroute(&ip6_dst, NULL, NULL, &ip6_rt,
+				     &ifp, &rt)) != 0) {
+ 		  
+		        return ENOATTR;
+		
+		};
+
+		if ( rt == NULL )  { /* No route to Destination RLOC */
+		  
+		        return ENOATTR;
+		
+		};
+		
+		bcopy( rt->rt_ifa, &out_ifa, 
+		       SS_SIZE(rt->rt_ifa));
+		RTFREE(rt);
+
+		break;
+
+	default:
+		        /* This should really never happen!
+			 */
+		         panic("[MAP_SELECT_SRCRLOC] AF Not Supported!");
+	};
+
+        struct locator_chain * lc = dbmap->rlocs;
+
+	while (lc 
+	       && !(lc->rloc.rloc_addr->ss_family == drloc->rloc_addr->ss_family)
+	       && !(lc->rloc.rloc_metrix.rlocmtx.flags & (RLOCF_UP | RLOCF_LIF))
+	       && (lc->rloc.rloc_metrix.rlocmtx.priority < MAX_RLOC_PRI)
+	       && (memcmp( &out_ifa, lc->rloc.rloc_addr, SS_SIZE(lc->rloc.rloc_addr)))) {
+	       /* Scan the chain and pick the first that:
+		* - Has the same AF
+		* - Is a local address 
+		* - Has a valid priority (i.e. less than 255)
+		* - Is the address of the ooutgoing interface
+		*/
+	        lc = lc->next;
+	};
+
+	if (lc) {
+
+	        *srloc = &(lc->rloc);
+  
+		lc->rloc.rloc_metrix.rloc_hit++;
+
+		return 0;
+	};
+
+	return ENOATTR;
+
+}  /* map_select_srcrloc() */
+
+int 
+map_select_dstrloc(struct mapentry * rmap, struct locator ** drloc)
+{
+        struct locator_chain * lc = rmap->rlocs;
+
+	while (lc && !(lc->rloc.rloc_metrix.rlocmtx.flags & RLOCF_UP)
+	          && (lc->rloc.rloc_metrix.rlocmtx.priority < MAX_RLOC_PRI)) {
+	       /* scan the chain and pick the first with status up and 
+		* with sufficient priority.
+		*/
+	        lc = lc->next;
+	};
+
+	if (lc) {
+
+	        *drloc = &(lc->rloc); 
+
+		lc->rloc.rloc_metrix.rloc_hit++;
+
+		return 0;
+	};
+
+	return ENOATTR;
+
+}  /* map_select_dstrloc() */
+
+
+void
+locked_dblookup(struct eidmap *emap)
+/*
+ * Lookups for mappings that are in the Database and locks the entry
+ */
+{
+          emap->mapping = maplookup((struct sockaddr *) &(emap->eid), MAPF_DB);
+
+}   /* locked_dblookup() */
+
+
+void
+dblookup(struct eidmap *emap)
+/*
+ * Lookups for mappings that are in the Database
+ */
+{
+        emap->mapping = maplookup((struct sockaddr *) &(emap->eid), MAPF_DB);
+
+	if (emap->mapping)
+	        MAP_UNLOCK(emap->mapping);
+
+}   /* dblookup() */
+
+void
+locked_cachelookup(struct eidmap *emap)
+/*
+ * Lookups for mappings that are in the cache and locks the entry
+ */
+{
+        emap->mapping = maplookup((struct sockaddr *) &(emap->eid), 0);
+
+
+	if ((emap->mapping) && ((emap->mapping->map_flags) & MAPF_DB)) {
+	       /* GgX - We found a DB map while we where looking 
+		* for a Cache map. Do not return this entry.
+		*/
+
+                MAP_UNLOCK(emap->mapping);
+		MAP_REMREF(emap->mapping);
+		emap->mapping = NULL;
+
+	};
+
+}   /* locked_cachelookup() */
+
+void
+cachelookup(struct eidmap *emap)
+/*
+ * Lookups for mappings that are in the cache
+ */
+{
+        emap->mapping = maplookup((struct sockaddr *) &(emap->eid), 0);
+
+
+	if ((emap->mapping) && ((emap->mapping->map_flags) & MAPF_DB)) {
+	       /* GgX - We found a DB map while we where looking 
+		* for a Cache map. Do not return this entry.
+		*/
+
+                MAP_UNLOCK(emap->mapping);
+		MAP_REMREF(emap->mapping);
+		emap->mapping = NULL;
+
+	};
+
+
+	if (emap->mapping)
+	        MAP_UNLOCK(emap->mapping);
+
+}   /* cachelookup() */
+
+
+static struct mapentry *
+maplookup(struct sockaddr *eid, int dbflag)
+/*
+ * Look up the mapping that matches the address given
+ * The returned map, if any, is locked.
+ */
+{
+        struct radix_node_head *rnh;
+	struct mapentry *map = NULL;	
+	struct mapentry *newmap = NULL;
+	struct radix_node *rn;
+	struct map_addrinfo info;
+	struct timeval timenow;
+
+	int    nflags;
+
+        MAPTABLES(rnh, eid->sa_family);
+
+	bzero(&info, sizeof(info));
+
+	/*
+	 * Look up the address in the table for that Address Family
+	 */
+	if (rnh == NULL) {
+	       /* GgX - Should I panic here? */
+	        (dbflag ? mappingstats.db.miss++ : mappingstats.cache.miss++);
+		
+		goto miss2;
+	}
+
+	RADIX_NODE_HEAD_LOCK(rnh);
+	if ((rn = rnh->rnh_matchaddr(eid, rnh)) &&
+	    (rn->rn_flags & RNF_ROOT) == 0) {
+	
+	        /* If we find it and it's not the root node, then
+		 * get a reference on the mapentry associated.
+		 */
+	
+		newmap = map = RNTOMAP(rn);
+		nflags = map->map_flags ;
+	
+		if ( dbflag != (nflags & MAPF_DB) ) {
+		     
+		        /* GgX - A Database map has been asked but the 
+                         * map found is in the cache or a cache map 
+			 * has been asked but the map found is in the 
+			 * database. 
+		         */
+
+			newmap = NULL;
+			goto miss;
+
+		} else {
+		       /* GgX - The mapping that we found is valid 
+			*/
+
+		        (dbflag ? mappingstats.db.hit++ : mappingstats.cache.hit++);
+
+			getmicrotime(&timenow);
+			newmap->map_lastused = timenow.tv_sec;
+
+		        KASSERT( map == newmap, ("looking the wrong map"));
+			MAP_LOCK(newmap);
+			MAP_ADDREF(newmap);
+
+		};
+
+		RADIX_NODE_HEAD_UNLOCK(rnh);
+
+	} else {
+		/*
+		 * Either we hit the root or couldn't find any match,
+		 * Which basically means "No Mapping available"
+		 */
+
+	miss:
+	         (dbflag ? mappingstats.db.miss++ : mappingstats.cache.miss++);
+	         RADIX_NODE_HEAD_UNLOCK(rnh);
+	
+	miss2:	
+
+
+#ifdef LISP_DEBUG
+		 /*
+		  * If required, report the failure to syslog.
+		  * Works only if lisp debugging is enabled.
+		  */
+      
+		 if (!dbflag && lispdebug) {
+
+		         char addrbuf[SOCK_MAXADDRLEN];
+
+			 switch (eid->sa_family) {
+			   
+			 case AF_INET6:
+			   
+			         (void) ip6_sprintf(addrbuf, &(((struct sockaddr_in6 *)eid)->sin6_addr));
+				 log(LOG_DEBUG,"[MAPLOOKUP] IPv6 Cache miss for EID: %s\n", addrbuf);
+				 break;
+
+			 case AF_INET:
+			 default:
+
+			         log(LOG_DEBUG,"[MAPLOOKUP] IPv4 Cache miss for EID: %s\n",
+				     inet_ntoa((((struct sockaddr_in *)eid)->sin_addr)));
+
+			 };
+
+		 } else if (dbflag && (lispdebug > LISP_BASIC_DEBUG)) {
+
+		         char addrbuf[SOCK_MAXADDRLEN];
+
+		         switch (eid->sa_family) {
+
+			 case AF_INET6:
+
+				 (void) ip6_sprintf(addrbuf, &(((struct sockaddr_in6 *)eid)->sin6_addr));
+				 log(LOG_DEBUG,"[MAPLOOKUP] IPv6 Database miss for EID: %s\n", addrbuf);
+				 break;
+
+			 case AF_INET:
+			 default:
+			   
+			         log(LOG_DEBUG,"[MAPLOOKUP] IPv4 Database miss for EID: %s\n",
+				     inet_ntoa((((struct sockaddr_in *)eid)->sin_addr)));
+
+			 };
+
+		 };
+#endif /* LISP_DEBUG */
+	
+	};
+
+	if (newmap) {
+		MAP_LOCK_ASSERT(newmap);
+	};
+
+	return (newmap);
+
+}   /* maplookup() */
+
+
+static void 
+FreeRloc(struct locator_chain * rlocchain)
+{
+  /* GgX - Remove the whole rloc chain */
+      
+        while (rlocchain) {
+               struct locator_chain * rc;
+
+	       Free(rlocchain->rloc.rloc_addr); /* rloc sockaddr*/
+	       rc = rlocchain;
+	       rlocchain = rlocchain->next;    
+	       Free(rc);                       /* chain node */
+        }
+} /* FreeRloc */
+
+
+
+
+/*
+ * Remove a reference count from an mapentry.
+ * If the count gets low enough, take it out of the routing table
+ */
+void
+mapfree(struct mapentry *map)
+{
+        struct radix_node_head *rnh;
+
+	KASSERT(map != NULL,("%s: NULL map", __func__));  
+
+	MAPTABLES(rnh, ((struct sockaddr_storage *)map_key(map))->ss_family);
+
+	KASSERT(rnh != NULL,("%s: NULL rnh", __func__));  
+
+	MAP_LOCK_ASSERT(map);
+
+	/*             
+	 * The callers should use RTFREE_LOCKED() or RTFREE(), so
+         * we should come here exactly with the last reference. 
+	 */ 
+	MAP_REMREF(map);
+        if (map->map_refcnt > 0) {
+	        printf("%s: %p has %lu refs\n", __func__, map, map->map_refcnt); 
+		goto done;
+         }   
+
+	/*
+         * On last reference give the "close method" a chance
+         * to cleanup private state.  This also permits (for  
+         * IPv4 and IPv6) a chance to decide if the routing table
+         * entry should be purged immediately or at a later time.
+	 */                                                     
+         if (map->map_refcnt == 0 && rnh->rnh_close)   
+                 rnh->rnh_close((struct radix_node *)map, rnh);  
+  
+	/*
+	 * If we are no longer "up" (and ref == 0)
+	 * then we can free the resources associated
+	 * with the route.
+	 */
+
+	if ((map->map_flags & MAPF_UP) == 0) {
+		if (map->map_nodes->rn_flags & (RNF_ACTIVE | RNF_ROOT))
+			panic ("mapfree !");
+		/*
+		 * the mapentry must have been removed from the mapping 
+		 * table so it is represented in rttrash.. remove that now.
+		 */
+		maptrash--;
+
+
+#ifdef	DIAGNOSTIC
+		if (map->map_refcnt < 0) {
+			printf("mapfree: %p not freed (neg refs)\n", map);
+			goto done;
+		}
+#endif
+
+		/* GgX - RLOCs are separatly alloc'd so free it 
+		 * (see map_setrlocs()).
+		 */
+		FreeRloc(map->rlocs);
+
+		/*
+		 * The key is separatly alloc'd so free it (see map_setentry()).
+		 */
+		Free(map_key(map));
+ 
+		/*
+		 * and the rtentry itself of course
+		 */
+		MAP_LOCK_DESTROY(map);
+		uma_zfree(mapzone, map);
+		return;
+		}
+done:
+	MAP_UNLOCK(map);
+}
+
+static walktree_f_t map_fixchange;
+
+struct mapfc_arg {
+	struct mapentry *map0;
+	struct radix_node_head *rnh;
+};
+
+/*
+ * These (questionable) definitions of apparent local variables apply
+ * to the next two functions.  XXXXXX!!!
+ */
+#define	eid	info->mapi_info[MAPX_EID]
+#define	rloc	info->mapi_info[MAPX_RLOC]
+#define	rlocnum	info->mapi_rloc_count
+#define	eidmask	info->mapi_info[MAPX_EIDMASK]
+#define	flags	info->mapi_flags
+#define	versioning	info->mapi_versioning
+
+
+int
+maprequest(int req, struct map_addrinfo *info, struct mapentry **ret_nmap)
+{
+  	int error = 0;
+	register struct mapentry *mapt;
+	register struct radix_node *rn;
+	register struct radix_node_head *rnh;
+	struct sockaddr_storage *neid;
+	struct timeval timenow;
+	
+#define senderr(x) { error = x ; goto bad; }
+
+
+	KASSERT(EID,"[MAPREQUEST] NULL pointer to EID!");
+
+	/*
+	 * Find the correct mapping tree to use for this Address Family
+	 */
+	MAPTABLES(rnh,eid->ss_family);
+	if (rnh == NULL)
+		return (EAFNOSUPPORT);
+       	RADIX_NODE_HEAD_LOCK(rnh);
+
+	/*
+	 * If we are adding a host eid then we don't want to put
+	 * a netmask in the tree.
+	 */
+
+	switch (req) {
+	case MAPM_DELETE:
+
+		/*
+		 * Remove the item from the tree and return it.
+		 * Complain if it is not there and do no more processing.
+		 */
+		rn = rnh->rnh_deladdr(eid, eidmask, rnh);
+		if (rn == NULL)
+			senderr(ESRCH);
+
+		if (rn->rn_flags & (RNF_ACTIVE | RNF_ROOT))
+			panic ("maprequest delete");
+
+		mapt = RNTOMAP(rn);
+		MAP_LOCK(mapt);
+		MAP_ADDREF(mapt);
+		mapt->map_flags &= ~MAPF_UP;
+
+		/*
+		 * One more mapentry floating around that is not
+		 * linked to the routing table. rttrash will be decremented
+		 * when MAPFREE(mapt) is eventually called.
+		 */
+		maptrash++;
+
+		/*
+		 * If the caller wants it, then it can have it,
+		 * but it's up to it to free the mapentry as we won't be
+		 * doing it.
+		 */
+		if (ret_nmap) {
+			*ret_nmap = mapt;
+			MAP_UNLOCK(mapt);
+		} else		        
+			MAPFREE_LOCKED(mapt);
+		break;
+
+	case MAPM_ADD:
+	       /* Check for flag correctness
+		*/
+	        if ( (flags & MAPF_ALL) ) {
+	                /* All flag cannot be set on adding */
+		
+#ifdef LISP_DEBUG
+		        DEBUGLISP("[MAPREQUEST] Invalid flags! \n");
+#endif /* LISP_DEBUG */
+
+			senderr(EINVAL);
+		};
+
+
+	       /* Beside the EID we need at least one rloc
+		* Unless it is a negative mapping.
+		*/
+      	        if ( !eid || 
+		     (!(flags & MAPF_NEGATIVE) && (!rloc || !rlocnum)) ||
+		     ((flags & MAPF_NEGATIVE) && (rloc || rlocnum))) {
+
+#ifdef LISP_DEBUG
+		       DEBUGLISP("[MAPREQUEST] RLOCs Provided for non-Negative mapping! \n");
+#endif /* LISP_DEBUG */
+
+		       senderr(EINVAL);
+		};
+
+		mapt = uma_zalloc(mapzone, M_NOWAIT | M_ZERO);
+		if (mapt == NULL)
+			senderr(ENOBUFS);
+
+		MAP_LOCK_INIT(mapt);
+		mapt->map_flags = MAPF_UP | flags;
+
+		/*
+		 * Add the rloc. Possibly re-malloc-ing the storage for it
+		 * also add the map.rlocs if possible.
+		 */
+		MAP_LOCK(mapt);
+		if ((error = map_setentry(mapt, eid)) != 0) {
+			Free(map_key(mapt));
+			MAP_LOCK_DESTROY(mapt);
+			uma_zfree(mapzone, mapt);
+#ifdef LISP_DEBUG
+			DEBUGLISP("[MAPREQUEST] No Bufs for new entry in MapTables \n");
+#endif /* LISP_DEBUG */
+			senderr(error);
+		}
+
+		/*
+		 * point to the (possibly newly malloc'd) eid address.
+		 */
+		neid = (struct sockaddr_storage *)map_key(mapt);
+		
+		/*
+		 * make sure it contains the value we want (masked if needed).
+		 */
+		if (eidmask) {
+			map_maskedcopy(eid, neid, eidmask);
+		} else
+			bcopy(eid, neid, eid->ss_len);
+		
+		rn = rnh->rnh_addaddr(neid, eidmask, rnh, mapt->map_nodes);
+		if (rn == NULL) {
+ 
+			senderr(EEXIST);
+		};
+
+		if (req == MAPM_ADD && map_mask(mapt) != NULL) {
+			struct mapfc_arg arg;
+			arg.rnh = rnh;
+			arg.map0 = mapt;
+			rnh->rnh_walktree_from(rnh, map_key(mapt), 
+					       map_mask(mapt),
+					       map_fixchange, &arg);
+		}
+
+
+		if ((mapt->rlocs_cnt = rlocnum) && 
+		    (error = map_setrlocs((caddr_t*)rloc, &mapt->rlocs, rlocnum,
+					  &mapt->rlocs_statusbits, 
+					  (mapt->map_flags & MAPF_DB)))) {
+		        /* GgX - Error occurred during rloc allocation 
+		         * free everything.
+		         */
+		  
+		        rn = rnh->rnh_deladdr(neid, eidmask, rnh);
+
+			Free(map_key(mapt));
+		        MAP_LOCK_DESTROY(mapt);
+			uma_zfree(mapzone, mapt);
+			senderr(error);
+		};
+
+		if ( !(mapt->map_flags & MAPF_NEGATIVE) &&
+		     (mapt->map_flags & MAPF_DB)  &&
+		     (error = map_fix_local_rlocs(mapt->rlocs))) {
+		        /* The check for local interface for local RLOCs
+			 * failed. Local mapping are allowed only if at
+			 * least one RLOC matches the address of an
+		         * interface.
+		         * Free Everything.
+			 */
+
+ 		        FreeRloc(mapt->rlocs);
+		  
+		        rn = rnh->rnh_deladdr(neid, eidmask, rnh);
+
+			Free(map_key(mapt));
+		        MAP_LOCK_DESTROY(mapt);
+			uma_zfree(mapzone, mapt);
+			senderr(error);
+		};
+
+		if (flags & MAPF_VERSIONING)
+		  mapt->vnum = htons(versioning);
+ 
+
+		getmicrotime(&timenow);
+		mapt->map_lastused = timenow.tv_sec;
+
+		/*
+		 * actually return a resultant mapentry and
+		 * give the caller a single reference.
+		 */
+		if (ret_nmap) {
+			*ret_nmap = mapt;
+			MAP_ADDREF(mapt);
+		}
+		MAP_UNLOCK(mapt);
+		break;
+	default:
+		error = EOPNOTSUPP;
+	}
+
+bad:
+	RADIX_NODE_HEAD_UNLOCK(rnh);
+	return (error);
+
+#undef senderr
+
+} /* End maprequest */
+
+#undef	eid	
+#undef	rloc	
+#undef	eidmask	
+#undef	rlocnum	
+#undef 	flags
+
+static int
+order_addr(struct sockaddr_storage * saddr1, struct sockaddr_storage * saddr2)
+{
+        /* The routine must return a value different from zero 
+	 * if saddr1 contains an address smaller than saddr2.
+	 * Note that IPv4 addresses are considered always as smaller 
+	 * than IPv6 addresses.
+	 */
+
+         uint8_t * chptr1 = NULL;
+         uint8_t * chptr2 = NULL;
+	 int length = 0;
+
+	 if ( saddr1->ss_family != saddr2->ss_family ) {
+	   
+	         if ( saddr1->ss_family == AF_INET )  {
+ 		        /* saddr1 (IPv4) < saddr2 (IPv6)
+			 */
+
+		         return (1);
+
+		 } else {
+ 		        /* saddr1 (IPv6) > saddr2 (IPv4)
+			 */
+
+ 		         return (0);
+
+		 };
+
+	 };
+
+	 /* The two addresse are in the same family 
+	  */
+	 
+	 switch (saddr1->ss_family) {
+
+	 case AF_INET:
+
+	   chptr1 = (uint8_t *) &(((struct sockaddr_in *) saddr1)->sin_addr);
+	   chptr2 = (uint8_t *) &(((struct sockaddr_in *) saddr2)->sin_addr);
+	
+	   break;
+
+	 case AF_INET6:
+
+	   chptr1 = (uint8_t *) &(((struct sockaddr_in6 *) saddr1)->sin6_addr);
+	   chptr2 = (uint8_t *) &(((struct sockaddr_in6 *) saddr2)->sin6_addr);
+	
+	   break;
+
+	 };
+
+	 while ( ( *chptr1 == *chptr2 ) && ( length < SS_SIZE(saddr1) ) ) {
+	         length++;
+		 chptr1++;
+		 chptr2++; 
+	 };
+
+	 if ( *chptr1 < *chptr2 ) {
+	        /* saddr1 < saddr2 
+		 */
+
+	         return (1);
+
+	 } else {
+	        /* saddr1  > saddr2 
+		 */
+
+	         return (0);
+
+	 };
+
+
+} /* cmp_addr() */
+
+
+static int
+map_insertrloc(struct locator_chain ** rlocchain, struct sockaddr_storage * rlocaddr, struct rloc_mtx * rlocmtx)
+/* 
+ * Inserts a new rloc into a locator_chain ordered by priority and weigth
+ * and address if necessary.
+ */
+{
+        struct locator_chain * newrloc, * rcp, * rcpp;
+   
+	struct sockaddr_storage * newrlocaddr;
+	int diff = 1;
+
+        R_Zalloc(newrloc, struct locator_chain *, sizeof(struct locator_chain));
+
+	if (newrloc == NULL)
+                return(ENOBUFS);
+
+        bzero(newrloc, sizeof(struct locator_chain));
+
+	bcopy(rlocmtx, &(newrloc->rloc.rloc_metrix.rlocmtx), 
+	      sizeof(struct rloc_mtx));
+
+        R_Zalloc(newrlocaddr, struct sockaddr_storage *, SS_SIZE(rlocaddr));
+
+	if (newrlocaddr == NULL) {
+	        Free(newrloc);
+                return(ENOBUFS);
+	};
+        bcopy(rlocaddr, newrlocaddr, SS_SIZE(rlocaddr));
+	newrloc->rloc.rloc_addr = newrlocaddr;
+
+        rcp = *rlocchain;
+		
+	/* GgX - Before inserting Check for duplicates
+	 * This is not efficient. If we see a lots of RLOCs for one 
+	 * EID prefix we should change this.
+	 */
+	while ( rcp && diff) {
+	   
+	        if ( rcp->rloc.rloc_addr->ss_family == newrloc->rloc.rloc_addr->ss_family) 
+		  diff = bcmp(rcp->rloc.rloc_addr, newrloc->rloc.rloc_addr, SS_SIZE(rcp->rloc.rloc_addr));
+	        else
+		        diff = 1;
+
+	        rcp = rcp->next;
+	};
+	 
+	if (!diff) {
+	        Free(newrlocaddr);
+		Free(newrloc)
+
+#ifdef LISP_DEBUG
+		DEBUGLISP("[MAP_INSERTRLOC] Duplicate RLOCs ! \n");
+#endif /* LISP_DEBUG */
+
+	        return(EINVAL);
+	};
+	 
+	rcpp = rcp = *rlocchain;
+
+        while ( rcp && 
+		(rcp->rloc.rloc_metrix.rlocmtx.priority < newrloc->rloc.rloc_metrix.rlocmtx.priority 
+		 || (rcp->rloc.rloc_metrix.rlocmtx.priority == newrloc->rloc.rloc_metrix.rlocmtx.priority 
+		     && order_addr(rcp->rloc.rloc_addr,newrloc->rloc.rloc_addr) ))) {
+
+	        rcpp = rcp;
+	        rcp = rcp->next;
+
+	};
+
+        if (rcp == NULL) {
+	       /* Either we are queuing at the end of the list
+		* or it is the first one 
+		*/ 
+	        if (rcpp)
+		        rcpp->next = newrloc;
+		else 
+	                *rlocchain = newrloc;
+	} else {
+	        if (rcp == rcpp) {
+	               /* We are at the head of the chain 
+			*/
+		        *rlocchain = newrloc;
+			newrloc->next = rcp;
+		} else {
+	                newrloc->next = rcp;
+		        rcpp->next = newrloc;
+		}
+  	};
+	
+        return(0);
+
+} /* map_appendrloc */
+
+
+static void 
+map_copylsbit(struct locator_chain * r_chain, lsbits_type * locbits)
+/*
+ * Scans the locator chain and make a copy of the status bit of each 
+ * RLOC in the Locator Status bits string.
+ */
+{
+        int shift = 0;
+	int ct = 0;
+
+        while (r_chain && (ct <= MAXRLOCS)) {
+	       
+	        if (r_chain->rloc.rloc_metrix.rlocmtx.flags & RLOCF_UP) {
+		  
+			shift = ct%MAXLBIT;      /* position in the byte */
+			*locbits |= htonl(LSBITSHIFT(shift)); 
+		};
+		ct++;
+		r_chain = r_chain->next;    
+        };
+
+
+}  /* map_copylsbit */
+
+
+static int
+map_setrlocs(caddr_t *rlocs, struct locator_chain ** rlocs_chain, int rlocs_ct, lsbits_type * lsbits, int db)
+/* 
+ * Create the chain of RLOCs.
+ * If lsbits is not NULL it creates as well the 
+ * Locator Status Bits String 
+ */
+{
+        int rlocs_counter = rlocs_ct;
+	struct locator_chain* lc = NULL;
+	char * cp =  (char *) rlocs;
+	struct rloc_mtx rmtx;
+	struct sockaddr_storage * ss;
+	int error = 0;
+	
+	while (rlocs_counter--) {
+	  
+	          ss = (struct sockaddr_storage *)cp;
+		  cp += SS_SIZE(ss);
+		  rmtx.priority = *(uint8_t *)cp++;
+		  rmtx.weight =  *(uint8_t *)cp++;
+		  rmtx.flags =  *(uint16_t *)cp;
+		  cp += sizeof(uint16_t);
+		  rmtx.mtu =  *(uint32_t *)cp;
+		  cp += sizeof(uint32_t);
+		  if (db) {  /* No nonce is stored in the DB */
+		          if (rmtx.flags & RLOCF_TXNONCE) {
+			          FreeRloc(*rlocs_chain);
+				  return(EINVAL);
+			  };         	  
+			  rmtx.tx_nonce.nvalue = 0; 
+		  } else {
+		          rmtx.tx_nonce.nvalue = (htonl( ((struct nonce_type *)cp)->nvalue & NONCEMASK)) >> 8;
+		  };
+		  cp += sizeof(struct nonce_type);
+		  rmtx.rx_nonce.nvalue = 0; /* Received nonce cannot be set.
+					     * Just reset it.
+					     */
+		  cp += sizeof(struct nonce_type);
+
+		  if ((error = map_insertrloc( &lc, ss, &rmtx))) {
+		           /* Free already allocated RLOCs then return
+			    */
+		            FreeRloc(*rlocs_chain);
+		            return(error);
+		  };         	  
+		  
+
+	};
+
+	*rlocs_chain = lc;
+
+	/* Update Locator Status Bits String if requested 
+	 */
+	if ( lsbits )
+	        map_copylsbit(lc, lsbits); 
+	
+	return(error);
+
+}  /* map_setrlocs */
+
+
+
+static int
+map_fixchange(struct radix_node *rn, void *vp)
+{
+
+  /* This will be filled up when the MAP_CHANGE will be implemented.
+   */
+        return 0;
+
+} /* map_fixchange */
+
+int
+map_setentry(struct mapentry *map, struct sockaddr_storage *eid)
+
+{
+        int eidlen = SS_SIZE(eid);
+
+	MAP_LOCK_ASSERT(map);
+
+	if (map->rlocs == NULL ) {
+	        /* This is a newly created entry */
+		caddr_t new;
+
+		R_Malloc(new, caddr_t, eidlen);
+
+		if (new == NULL)
+			return ENOBUFS;
+		/*
+		 * XXX note, we copy from *eid and not *map_key(map) because
+		 * map_add_rloc() can be called to initialize a newly
+		 * allocated map entry, in which case map_key(map) == NULL
+		 * (and also map->rlocs == NULL).
+		 * Map_Free() handles a NULL argument just fine.
+		 */
+		bcopy(eid, new, eidlen);
+
+		Free(map_key(map));	/* free old block, if any */
+
+		map_key(map) = (struct sockaddr *)new;
+
+	}
+
+	return 0;
+}
+
+
+
+static void
+map_maskedcopy(struct sockaddr_storage *src, struct sockaddr_storage *dst, struct sockaddr_storage *netmask)
+{
+	register u_char *cp1 = (u_char *)src;
+	register u_char *cp2 = (u_char *)dst;
+	register u_char *cp3 = (u_char *)netmask;
+	u_char *cplim = cp2 + *cp3;
+	u_char *cplim2 = cp2 + *cp1;
+
+	*cp2++ = *cp1++; *cp2++ = *cp1++; /* copies sa_len & sa_family */
+	cp3 += 2;
+	if (cplim > cplim2)
+		cplim = cplim2;
+	while (cp2 < cplim)
+		*cp2++ = *cp1++ & *cp3++;
+	if (cp2 < cplim2)
+		bzero((caddr_t)cp2, (unsigned)(cplim2 - cp2));
+}
+
+
+SYSINIT(map, SI_SUB_PROTO_DOMAIN, SI_ORDER_ANY, maptables_init, 0);
+ 
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/net/lisp/maptables.h freebsd-10.1.0-LISP/sys/net/lisp/maptables.h
--- freebsd-10.1.0-RELEASE/sys/net/lisp/maptables.h	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/net/lisp/maptables.h	2014-12-14 13:47:08.817161060 +0100
@@ -0,0 +1,445 @@
+/*- /usr/src/sys/net/lisp/maptables.h
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *
+ * $Id: maptables.h 177 2011-09-22 14:33:51Z ggx $
+ *
+ */
+
+/*
+ *  Copyright (c) 1980, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef _MAP_TABLES_H_
+#define _MAP_TABLES_H_
+
+#ifdef _KERNEL
+#include "opt_lisp.h"
+#include "opt_inet.h"
+#include "opt_inet6.h"
+#endif /*_KERNEL*/
+
+#include <net/radix.h>
+#include <netinet/in.h>
+
+
+#define IPv4_EIDs_TABLE 0
+#define IPv6_EIDs_TABLE 1
+#define MAX_TABLES 2
+
+/* MAPTABLES returns the pointer to the radix_node_head of the 
+ * maptables for AF_INET and AF_INET6, NULL otherwise.
+ */
+#define MAPTABLES(m,t)						\
+        if (t == AF_INET) {					\
+	       m = map_tables[IPv4_EIDs_TABLE];			\
+	} else if (t == AF_INET6) {                             \
+	       m = map_tables[IPv6_EIDs_TABLE];			\
+	       } else { m = NULL; }
+
+
+/* Useful constant */
+#define MAX_RLOC_PRI  255   /* Max allowed priority. A value of 
+			     * 255 means that that RLOC MUST not 
+			     * be used.
+			     */
+
+struct rloc_mtx {           /* GgX - Metrics associated to the RLOC
+			     * Usefull for messages mapping sockets 
+			     */
+
+        uint8_t priority;    /* GgX - Each RLOC has a priority. 
+			      */
+        uint8_t weight;      /* GgX - Each locator has a weight. Used for 
+			      * for load balancing pusposes when two or
+			      * more locators have the same priority.
+			      * The sum of the weight fields of all rlocs 
+			      * having the same priority must always be 100
+			      * or 0. the latter means all to 0.
+			      */
+        uint16_t flags;      /* GgX it is 16 bit to achieve 32 alignment
+			      * and contains useful flags	
+			      */
+
+        uint32_t mtu;        /* GgX - MTU for the specific RLOC.
+			      * This entry is meaningful only for local
+			      * mapping (i.e., part of the database)
+			      * for wich the flag 'i' is set (local interface).
+			      * The field is initialized only at creation
+			      * by copying the value of the corresponding
+			      * interface. If the MTU of the interface 
+			      * changes afterwards, the field is not updated.
+			      * 
+			      * By now mtu given through mapping sockets 
+			      * is ignored.
+			      */
+
+        struct nonce_type tx_nonce; /* Nonce to be used when sending a
+				    * LISP encapsulated packet to the RLOC.
+				    */
+
+        struct nonce_type rx_nonce; /* Nonce to be used when receiving a
+				     * LISP encapsulated packet to the RLOC.
+				     */
+
+};
+
+/* RLOC metrics Flags Definition */
+#define RLOCF_UP        0x01    /* RLOC Status bit . */ 
+#define RLOCF_LIF       0x02    /* RLOC is a local interface.
+				 * This is only valid for local mappings.
+				 */
+#define RLOCF_TXNONCE     0x04    /* RLOC Tx Nonce present. */ 
+#define RLOCF_RXNONCE     0x08    /* RLOC Rx Nonce present. */ 
+
+struct rloc_metrics {
+
+	u_long	 rlocmtx_locks;/* Kernel must leave these values alone */
+
+        struct rloc_mtx rlocmtx; /* GgX -  Metrics     */
+
+	u_long	rloc_hit; /* Number of times this RLOC has been selected */
+
+};
+
+
+/*
+ * An  entry consists of a source address (or subnet) (EIDs)
+ * and a reference to a LISP entry. The LISP entry is a set of RLOCs.
+ */
+
+/* GgX - An RLOC is either an IPv6 or an IPv4 full ip address.
+ * This is why a sockaddr_storage is used.
+ * 
+ */
+struct locator {
+        struct sockaddr_storage * rloc_addr;
+        struct rloc_metrics rloc_metrix;
+};
+
+
+
+/* GgX - Since there can be several locators associated to the same EID 
+ * the locator data structure includes a pointer in order to create lists
+ */ 
+
+struct locator_chain{
+        struct locator rloc;
+        struct locator_chain * next;	     
+};
+
+
+struct mapentry {
+	struct	radix_node map_nodes[2];    /* tree glue, and other values */
+	/* GgX - From original code:
+	 * XXX struct mapentry must begin with a struct radix_node 
+	 * (or two!) because the code does some casts of 
+	 * a 'struct radix_node *' to a 'struct mapentry *'
+	 */
+#define	map_key(r)	(*((struct sockaddr **)(&(r)->map_nodes->rn_key)))
+#define	map_mask(r)	(*((struct sockaddr **)(&(r)->map_nodes->rn_mask)))
+#define	map_rlocsnum(r)	((r)->rlocs_cnt)
+#define	map_rlocs(r)	((r)->rlocs)
+
+        struct locator_chain * rlocs;  /* Set of locators */
+        int    rlocs_cnt;              /* Number of rlocs */
+        lsbits_type rlocs_statusbits;  /* Needed for compatibility with 
+					* ITR not supporting versioning
+					*/
+        uint16_t vnum;                 /* Version Number of the mapping
+					*/ 
+        uint16_t pad;                  /* Just to keep 32 bits alignment.
+					*/
+	u_long	 map_flags;		/* local/remote? */
+	long	 map_refcnt;		/* # held references */
+        time_t   map_lastused;          /* When the mapping has been used
+					 * last time
+					 */
+
+#ifdef _KERNEL
+ /* XXX ugly, user apps use this definition but don't have a mtx def */
+	struct	mtx map_mtx;		/* mutex for map entry */
+#endif
+};
+
+
+/* GgX - A mapping for a specific EID consists of a mapentry
+ * and the EID itself.
+ */
+struct eidmap {
+        struct mapentry *mapping;
+        struct sockaddr_storage eid;
+};
+
+
+#define	MAPF_DB	        0x001	/* Mapping is part of the Database */
+#define	MAPF_VERSIONING	0x002	/* Mapping uses Versioning */
+#define	MAPF_LOCBITS	0x004	/* Mapping uses LocStatus bits */
+#define MAPF_STATIC	0x008	/* manually added */
+#define	MAPF_UP		0x010	/* Mapping usable */
+#define	MAPF_ALL	0x020	/* Operation concerns both DB and Cache */
+#define MAPF_EXPIRED    0x040   /* Not used for more than XPGTO time */
+#define MAPF_NEGATIVE   0x080   /* Negative Mapping (no RLOCs forward 
+				 * natively)
+				 */
+#define MAPF_DONE	0x100	/* message confirmed */
+
+
+/*
+ * Mapping statistics (Mixed IPv4 IPv6).
+ */
+struct	mapstats {
+        uint64_t    miss;    /* failed lookups */
+        uint64_t    hit;     /* successfull lookups */
+};
+
+struct	mappingstats {
+
+        struct mapstats db;    /* Database Stats */
+
+        struct mapstats cache; /* Cache Stats */
+};
+
+/*
+ * Structures for routing messages.
+ */
+struct map_msghdr {
+	uint8_t	 map_msglen;	/* to skip over non-understood messages */
+	uint8_t	 map_version;   /* future binary compatibility */
+	uint16_t map_type;	/* message type */
+
+	uint32_t map_flags;	/* flags, incl. kern & message, e.g. DONE */
+	uint16_t map_addrs;	/* bitmask identifying sockaddrs in msg */
+        uint16_t map_versioning;/* Mapping Version Number */
+
+        int     map_rloc_count;/* Number of rlocs appended to the msg */
+	pid_t	map_pid;	/* identify sender */
+	int	map_seq;	/* for sender to identify action */
+	int	map_errno;	/* why failed */
+
+};
+
+#define MAPM_VERSION	1	/* Up the ante and ignore older versions */
+
+/*
+ * Message types.
+ */
+#define MAPM_ADD	   0x01	 /* Add Map */
+#define MAPM_DELETE	   0x02	 /* Delete Map */
+#define MAPM_CHANGE	   0x03	 /* Change Mapping (not yet implemented) */
+#define MAPM_GET 	   0x04	 /* Get matching mapping */
+#define MAPM_MISS          0x05  /* Lookup Failed  (general case) */
+#define MAPM_MISS_EID      0x06  /* Lookup Failed  and EID returned */
+#define MAPM_MISS_HEADER   0x07  /* Lookup Failed  and IP header returned */
+#define MAPM_MISS_PACKET   0x08  /* Lookup Failed  and Packet returned */
+#define MAPM_LSBITS        0x09  /* Locator Status Bits Changed */
+#define MAPM_LOCALSTALE    0x0A  /* Local Map Version is stale */
+#define MAPM_REMOTESTALE   0x0B  /* Remote Map Version is stale */
+#define MAPM_NONCEMISMATCH 0x0C  /* Rceived a mismatching nonce */
+
+
+/* Sysctl missmsg state definition
+ */
+#define LISP_MISSMSG_EID           1
+#define LISP_MISSMSG_HEADER        2
+#define LISP_MISSMSG_PACKET        3
+
+/* Sysctl ETR state definition
+ */
+#define LISP_ETR_STANDARD          1
+#define LISP_ETR_NOTIFY            2
+#define LISP_ETR_SECURE            3
+
+/*
+ * Bitmask values for map_addrs.
+ */
+#define MAPA_EID	0x01	 /* EID sockaddr present */
+#define MAPA_EIDMASK	0x02	 /* netmask sockaddr present */
+#define MAPA_RLOC	0x04	 /* Locator present */
+
+/*
+ * Index offsets for sockaddr array for alternate internal encoding.
+ */
+#define MAPX_EID	0	 /* EID sockaddr present */
+#define MAPX_EIDMASK	1	 /* EIDmask sockaddr present */
+#define MAPX_RLOC	2	 /* RLOC sockaddr present */
+#define MAPX_MAX	3	 /* size of array to allocate */
+
+struct map_addrinfo {
+	int	 mapi_addrs;
+	struct	sockaddr_storage *mapi_info[MAPX_MAX];
+        /* GgX - RLOC is a chain, thus  needs a different treatment. 
+         * When using mapi_info[MAPX_RLOC] we have to cast
+         * the pointer to a locator_chain struct
+	 */
+        uint32_t mapi_rloc_count; /* Number of rlocs */   
+	int	 mapi_flags;
+        uint16_t mapi_versioning; /* Map Versioning Number */
+
+        uint16_t pad;             /* Not used. It just keeps the whole 
+				   * structure 32 bits aligned! 
+				   */
+};
+ 
+/*
+ * This macro returns the size of a struct sockaddr when passed
+ * through a routing socket. Basically we round up ss_len to
+ * a multiple of sizeof(long), with a minimum of sizeof(long).
+ * The check for a NULL pointer is just a convenience, probably never used.
+ * The case ss_len == 0 should only apply to empty structures.
+ * Since we never use port, flow label or other, there are at least 
+ * 16 bit that are wasted. But alignment helps in speeding up
+ * memory transfers.
+ */
+#define SS_SIZE(ss)							\
+    (  (!(ss) || ((struct sockaddr_storage *)(ss))->ss_len == 0) ?	\
+       sizeof(long)		:					\
+	1 + ( (((struct sockaddr_storage *)(ss))->ss_len - 1) | (sizeof(long) - 1) ) )
+
+/* GgX - Gives back the size of the chunk of memory necessary to
+ * store an rloc. The size is give from the size of the sockaddr itself
+ * plus the locator chain overhead.
+ */
+#define RLOC_SIZE(ss)							\
+    (  (!(ss) || ((struct sockaddr_storage *)(ss))->ss_len == 0) ?	\
+       (sizeof(struct locator_chain) + sizeof(long))		:	\
+	sizeof(struct locator_chain) + 1 + ( (((struct sockaddr_storage *)(ss))->ss_len - 1) | (sizeof(long) - 1) ) )
+
+
+
+#ifdef _KERNEL
+
+#define	MAP_LOCK_INIT(_map) \
+	mtx_init(&(_map)->map_mtx, "mapentry", NULL, MTX_DEF | MTX_DUPOK)
+
+
+#define	MAP_LOCK(_map)		mtx_lock(&(_map)->map_mtx)
+
+#define	MAP_UNLOCK(_map)	mtx_unlock(&(_map)->map_mtx)
+
+#define	MAP_LOCK_DESTROY(_map)	mtx_destroy(&(_map)->map_mtx)
+
+#define	MAP_LOCK_ASSERT(_map)	mtx_assert(&(_map)->map_mtx, MA_OWNED)
+
+
+#define	MAP_ADDREF(_map) do {					\
+	MAP_LOCK_ASSERT(_map);					\
+	KASSERT((_map)->map_refcnt >= 0,			\
+		("negative refcnt %ld", (_map)->map_refcnt));	\
+	(_map)->map_refcnt++;					\
+	} while (0)
+
+#define	MAP_REMREF(_map) do {					\
+	MAP_LOCK_ASSERT(_map);					\
+	KASSERT((_map)->map_refcnt > 0,				\
+		("bogus refcnt %ld", (_map)->map_refcnt));	\
+	(_map)->map_refcnt--;					\
+        } while (0)
+
+#define	MAPFREE_LOCKED(_map) do {				\
+		if ((_map)->map_refcnt <= 1)			\
+			mapfree(_map);				\
+		else {						\
+			MAP_REMREF(_map);			\
+			MAP_UNLOCK(_map);			\
+		}						\
+		/* guard against invalid refs */		\
+		_map = 0;					\
+	} while (0)
+	
+#define	MAPFREE(_map) do {					\
+		MAP_LOCK(_map);					\
+		MAPFREE_LOCKED(_map);				\
+	} while (0)
+
+
+#define FREE_EIDMAP(_eidmap)				\
+        MAP_REMREF(_eidmap->mapping);			\
+	free(_eidmap, M_TEMP);
+
+
+extern struct radix_node_head *map_tables[MAX_TABLES];
+
+void	 map_notifymsg(int, struct map_addrinfo *, struct mapentry *,
+		       struct mbuf **, int, int *);
+
+int	 map_setentry(struct mapentry *, struct sockaddr_storage *);
+struct locator * map_findrloc(struct mapentry *, struct sockaddr_storage *);
+
+int      map_select_srcrloc(struct mapentry * , struct locator *, 
+			    struct locator **);
+
+int      map_select_dstrloc(struct mapentry *, struct locator ** );
+int      map_check_lsbits(struct mapentry * , lsbits_type * );
+int      map_notify_smr(struct sockaddr_storage * eid);
+
+/*
+ * Note the following locking behavior:
+ *
+ *    dblookup(), cachelooup(), maprequest() return map->mapping unlocked
+ */
+void     dblookup(struct eidmap *);
+void     cachelookup(struct eidmap *);
+void     locked_dblookup(struct eidmap *);
+void     locked_cachelookup(struct eidmap *);
+int	 maprequest(int, struct map_addrinfo *, struct mapentry **);
+void	 mapfree(struct mapentry *);
+
+#endif /* _KERNEL */
+ 
+
+#endif /* _MAP_TABLES_H_ */
+
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/net/lisp/maptables_xpg.c freebsd-10.1.0-LISP/sys/net/lisp/maptables_xpg.c
--- freebsd-10.1.0-RELEASE/sys/net/lisp/maptables_xpg.c	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/net/lisp/maptables_xpg.c	2014-12-14 13:47:08.817161060 +0100
@@ -0,0 +1,266 @@
+/*- /usr/src/sys/net/lisp/maptables.c
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *
+ * $Id: maptables_xpg.c 176 2011-09-22 14:06:30Z ggx $
+ *
+ */
+
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/sysctl.h>
+#include <sys/socket.h>
+#include <sys/mbuf.h>
+#include <sys/syslog.h>
+#include <sys/callout.h>
+
+#include <net/if.h>
+#include <net/route.h>
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+#include <net/lisp/maptables_xpg.h>
+
+#include <netinet/in.h>
+#include <netinet/in_var.h>
+#include <netinet/ip_var.h>
+
+
+/*
+ * Default values
+ */
+
+#define CACHE_XPGTO         10*60          
+#define CACHE_XPGTO_STRING "600"  /* Default Interval to check the  
+				   * Cache and expunge expired entries
+				   * is 10 Minutes.
+				   * This must be defined as string
+				   * due to initialization.
+				   * The timeout is expressed in SECONDS
+				   * but the values actuall value is stored
+				   * in seconds.
+				   * The two definition above MUST be always
+				   * consistent.
+				   */
+#define CACHE_MINXPGTO	60        /* Minimum Interval to check the cache
+				   * and expunge expired entries: 1 minute
+				   */
+#define CACHE_MAXXPGTO	60*60*24  /* Maximum Interval to check the cache 
+				   * and expunge expired entries:24 Hours 
+				   */ 
+#define CACHE_XPGTO_OFF   "off"   /* Turned off string
+				   */
+
+/*
+ * Expunge Timer and args
+ */
+
+struct callout maptable_xpg_timer[MAX_TABLES];
+
+struct xpgto_args maptable_xpgto_args[MAX_TABLES];
+
+struct maptable_xpg_arg {
+	struct radix_node_head *rnh;
+        int expunged;
+	int expired;
+	int found;
+};
+
+
+/*
+ * Sysctl to control Expunger
+ */
+
+SYSCTL_DECL(_net_lisp);
+
+
+/*
+ * Cache Entries' Expunger
+ */
+
+static uint32_t  lisp_cache_xpgto = CACHE_XPGTO;
+static char lisp_cache_xpgto_string[LISPMAXSTRLEN] = CACHE_XPGTO_STRING;
+
+
+static int
+sysctl_net_lisp_cache_xpg(SYSCTL_HANDLER_ARGS)
+{
+  uint32_t new = 0;
+  uint32_t old = lisp_cache_xpgto;
+  int error = 0;
+  int i = 0;
+
+  char tmpvalue[LISPMAXSTRLEN];
+
+ 
+  strcpy(tmpvalue, lisp_cache_xpgto_string);
+
+  error = sysctl_handle_string(oidp, lisp_cache_xpgto_string, 
+			       LISPMAXSTRLEN, req);
+  
+  if (error || req->newptr == NULL) 
+          return (error);
+
+  if ( strcmp(lisp_cache_xpgto_string, CACHE_XPGTO_OFF) ) {
+
+          new = (uint32_t)strtoul(lisp_cache_xpgto_string, NULL, 10); 
+
+	  if ((!new) || (new < CACHE_MINXPGTO) || (new > CACHE_MAXXPGTO))  {
+
+	         strcpy(lisp_cache_xpgto_string, tmpvalue);
+		 return(EINVAL);
+
+	  };
+	  
+  };
+
+  lisp_cache_xpgto = new;
+
+  if ( old && !lisp_cache_xpgto ) {
+          /* Stop All Timers */
+          for(i = 0; i < MAX_TABLES; i++) {
+
+	         callout_stop(&maptable_xpg_timer[i]);
+    
+	  };
+
+  } else if ( !old && lisp_cache_xpgto ) {
+          /* Re-Start All Timers */
+          for(i = 0; i < MAX_TABLES; i++) {
+
+	         lisp_cache_xpg_to(&maptable_xpgto_args[i]);
+    
+	  };
+  };
+  
+  return (0);
+
+} /* sysctl_net_lisp_cachetimeout() */
+
+SYSCTL_PROC(_net_lisp, OID_AUTO, xpgtimer, CTLTYPE_STRING | CTLFLAG_RW, 
+	    0, 0, sysctl_net_lisp_cache_xpg,"A",
+	   "LISP-Cache Expunger Timer");
+ 
+
+static int  lisp_cache_expired(struct radix_node *, void *);
+
+
+void
+lisp_cache_xpg_to(void * xpgargs)
+{
+  
+        struct radix_node_head *rnh = ((struct xpgto_args *)xpgargs)->rnh;
+	struct maptable_xpg_arg arg;
+	struct timeval atv;
+	struct callout *timer;
+
+	MAPTABLETIMER(timer,(((struct xpgto_args *)xpgargs)->af_family));
+
+	bzero(&arg, sizeof(arg));
+	arg.rnh = rnh;
+
+	RADIX_NODE_HEAD_LOCK(rnh);
+	rnh->rnh_walktree(rnh, lisp_cache_expired, &arg);
+	RADIX_NODE_HEAD_UNLOCK(rnh);
+
+#ifdef LISP_DEBUG
+	log(LOG_DEBUG,"[LISP_CACHE_XPG] Expunged %d out of  %d Expired Entries (out of %d)\n",
+	    arg.expunged, arg.expired, arg.found);
+#endif /* LISP_DEBUG */
+       
+	atv.tv_usec = 0;
+	atv.tv_sec = lisp_cache_xpgto;
+	callout_reset(timer, tvtohz(&atv), lisp_cache_xpg_to, xpgargs);
+
+}  /* lisp_cachexpg_to() */
+
+
+static int
+lisp_cache_expired(struct radix_node *rn, void * xpgarg)
+{
+
+	struct maptable_xpg_arg *argptr = xpgarg;
+	struct mapentry *mapping = (struct mapentry *)rn;
+	struct map_addrinfo mapinfo;
+	struct timeval timenow;
+
+	int err = 0;
+
+	RADIX_NODE_HEAD_WLOCK_ASSERT(argptr->rnh);
+
+	if (!(mapping->map_flags & MAPF_DB)) {
+
+		argptr->found++;
+
+		getmicrotime(&timenow);
+				
+		if (!(mapping->map_flags & MAPF_STATIC) &&
+		    (timenow.tv_sec - mapping->map_lastused) > lisp_cache_xpgto) {
+
+		        argptr->expired++;
+
+			bzero(&mapinfo, sizeof(mapinfo));
+			mapinfo.mapi_addrs |= MAPA_EID;
+			mapinfo.mapi_info[MAPX_EID] = (struct sockaddr_storage *) map_key(mapping);
+			mapinfo.mapi_addrs |= MAPA_EIDMASK;
+			mapinfo.mapi_info[MAPX_EIDMASK] = (struct sockaddr_storage *) map_mask(mapping);
+			
+			mapping->map_flags |= MAPF_EXPIRED;
+
+			map_notifymsg(MAPM_DELETE, &mapinfo, mapping, NULL, 
+				      0, &err);
+
+			if (err) {
+			  log(LOG_WARNING, "[LISP_CACHE_EXPIRED]: error %d sending notification through mapping socket\n", err);
+				/* XXX - Should Panic? */
+			  };
+
+			err = maprequest(MAPM_DELETE, &mapinfo, NULL);
+
+			if (err) {
+			  log(LOG_WARNING, "[lisp_cache_expired]: error %d\n", err);
+				/* XXX - Should Panic? */
+			} else {
+
+			  argptr->expunged++;
+
+			};
+
+		};
+
+
+	};
+
+	return 0;
+
+} /* lisp_cache_expired() */
+
+
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/net/lisp/maptables_xpg.h freebsd-10.1.0-LISP/sys/net/lisp/maptables_xpg.h
--- freebsd-10.1.0-RELEASE/sys/net/lisp/maptables_xpg.h	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/net/lisp/maptables_xpg.h	2014-12-14 13:47:08.817161060 +0100
@@ -0,0 +1,65 @@
+/*- /usr/src/sys/net/lisp/maptables_xpg.h
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *
+ * $Id: maptables_xpg.h 177 2011-09-22 14:33:51Z ggx $
+ *
+ */
+
+#ifndef _MAPTABLES_XPG_H_
+#define _MAPTABLES_XPG_H_
+
+#include <net/lisp/maptables.h>
+
+#define MAPTABLETIMER(m,t)					\
+        if (t == AF_INET) {					\
+	       m = &maptable_xpg_timer[IPv4_EIDs_TABLE];	\
+	} else if (t == AF_INET6) {                             \
+	       m = &maptable_xpg_timer[IPv6_EIDs_TABLE];	\
+	       } else { m = NULL; }
+
+
+/*
+ * Expunge Timer
+ */
+extern struct callout maptable_xpg_timer[];
+
+struct xpgto_args {
+
+  struct radix_node_head *rnh;
+  int af_family;
+
+};
+
+extern struct xpgto_args maptable_xpgto_args[];
+
+void lisp_cache_xpg_to(void *);
+
+#endif  /*_MAPTABLES_XPG_H_*/
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/net/netisr.h freebsd-10.1.0-LISP/sys/net/netisr.h
--- freebsd-10.1.0-RELEASE/sys/net/netisr.h	2014-12-05 22:11:06.990647233 +0100
+++ freebsd-10.1.0-LISP/sys/net/netisr.h	2014-12-14 13:47:08.817161060 +0100
@@ -61,6 +61,9 @@
 #define	NETISR_IPV6	10
 #define	NETISR_NATM	11
 #define	NETISR_EPAIR	12		/* if_epair(4) */
+#ifdef LISP
+#define NETISR_MAPPING	13
+#endif /* LISP */
 
 /*
  * Protocol ordering and affinity policy constants.  See the detailed
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/netinet/ip_input.c freebsd-10.1.0-LISP/sys/netinet/ip_input.c
--- freebsd-10.1.0-RELEASE/sys/netinet/ip_input.c	2014-12-05 22:07:29.253831410 +0100
+++ freebsd-10.1.0-LISP/sys/netinet/ip_input.c	2014-12-14 13:47:08.829167056 +0100
@@ -38,6 +38,7 @@
 #include "opt_ipsec.h"
 #include "opt_kdtrace.h"
 #include "opt_route.h"
+#include "opt_lisp.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -78,6 +79,11 @@
 #ifdef IPSEC
 #include <netinet/ip_ipsec.h>
 #endif /* IPSEC */
+#ifdef LISP
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+#include <netinet/lisp/ip_lisp.h>
+#endif /* LISP */
 
 #include <sys/socketvar.h>
 
@@ -730,6 +736,20 @@
 	 * Switch out to protocol's input routine.
 	 */
 	IPSTAT_INC(ips_delivered);
+	
+#ifdef LISP
+	if (lisp_ip_needdecap(&m)) {
+		ip->ip_len = ntohs(ip->ip_len);
+		ip->ip_len -= hlen;
+		ip->ip_off = ntohs(ip->ip_off);
+		
+		/*
+		 * GgX - We have a LISP packet.
+		 */
+		lisp_input(m, hlen);
+		return;
+	};
+#endif /* LISP */
 
 	(*inetsw[ip_protox[ip->ip_p]].pr_input)(m, hlen);
 	return;
@@ -1344,11 +1364,18 @@
 {
 	struct ip *ip = mtod(m, struct ip *);
 	struct in_ifaddr *ia;
+#ifdef LISP
+	ia = NULL;
+#endif /* LISP */
 	struct mbuf *mcopy;
 	struct in_addr dest;
 	struct route ro;
 	int error, type = 0, code = 0, mtu = 0;
 
+#ifdef LISP
+	int need_lisp_encap = 0;
+#endif /* LISP */
+
 	if (m->m_flags & (M_BCAST|M_MCAST) || in_canforward(ip->ip_dst) == 0) {
 		IPSTAT_INC(ips_cantforward);
 		m_freem(m);
@@ -1366,6 +1393,10 @@
 	}
 #endif
 
+#ifdef LISP
+	if ( !srcrt && !(need_lisp_encap = lisp_ip_needencap( &m )) ) {
+#endif /* LISP */
+
 	ia = ip_rtaddr(ip->ip_dst, M_GETFIB(m));
 #ifndef IPSEC
 	/*
@@ -1379,6 +1410,10 @@
 	}
 #endif
 
+#ifdef LISP
+	};
+#endif /* LISP */
+
 	/*
 	 * Save the IP header and at most 8 bytes of the payload,
 	 * in case we need to generate an ICMP message to the src.
@@ -1429,8 +1464,13 @@
 	 * or a route modified by a redirect.
 	 */
 	dest.s_addr = 0;
+#ifdef LISP
+	if (!srcrt && !need_lisp_encap && V_ipsendredirects &&
+	    ia != NULL && ia->ia_ifp == m->m_pkthdr.rcvif) {
+#else
 	if (!srcrt && V_ipsendredirects &&
 	    ia != NULL && ia->ia_ifp == m->m_pkthdr.rcvif) {
+#endif /* LISP */
 		struct sockaddr_in *sin;
 		struct rtentry *rt;
 
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/netinet/ip_output.c freebsd-10.1.0-LISP/sys/netinet/ip_output.c
--- freebsd-10.1.0-RELEASE/sys/netinet/ip_output.c	2014-12-05 22:07:29.237823411 +0100
+++ freebsd-10.1.0-LISP/sys/netinet/ip_output.c	2014-12-14 13:47:08.829167056 +0100
@@ -40,6 +40,7 @@
 #include "opt_mpath.h"
 #include "opt_route.h"
 #include "opt_sctp.h"
+#include "opt_lisp.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -78,6 +79,11 @@
 #include <netinet/sctp.h>
 #include <netinet/sctp_crc32.h>
 #endif
+#ifdef LISP
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+#include <netinet/lisp/ip_lisp.h>
+#endif /* LISP */
 
 #ifdef IPSEC
 #include <netinet/ip_ipsec.h>
@@ -139,6 +145,12 @@
 #ifdef IPSEC
 	int no_route_but_check_spd = 0;
 #endif
+
+#ifdef LISP
+	struct eidmap *local_map = NULL;
+	struct eidmap *remote_map = NULL;
+#endif /* LISP */
+
 	M_ASSERTPKTHDR(m);
 
 	if (inp != NULL) {
@@ -268,6 +280,24 @@
 			have_ia_ref = 1;
 		isbroadcast = 0;	/* fool gcc */
 	} else {
+
+
+#ifdef LISP
+	/*  GgX - Before perform normal routing check if we have to
+	 *  perform LISP encap.
+	 *  If no encapsulation is possible we continue with 
+	 * "traditional" operation (kind of fall-back 
+	 * approach.
+	 */
+	if (((error = lisp_ip_mapencap(&m, flags, &local_map, 
+	    &remote_map)) == 0) && local_map ) {
+		error = lisp_output(m, hlen, local_map, remote_map);
+		goto done; 
+	} else if (error) {
+		goto bad;
+	}; 
+#endif /* LISP */
+
 		/*
 		 * We want to do any cloning requested by the link layer,
 		 * as this is probably required in all cases for correct
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/netinet/ip_var.h freebsd-10.1.0-LISP/sys/netinet/ip_var.h
--- freebsd-10.1.0-RELEASE/sys/netinet/ip_var.h	2014-12-05 22:07:29.237823411 +0100
+++ freebsd-10.1.0-LISP/sys/netinet/ip_var.h	2014-12-14 13:47:08.833169057 +0100
@@ -162,6 +162,13 @@
 #define IP_ROUTETOIF		SO_DONTROUTE	/* 0x10 bypass routing tables */
 #define IP_ALLOWBROADCAST	SO_BROADCAST	/* 0x20 can send broadcast packets */
 
+#ifdef LISP
+#define IP_LISP                 0x40            /* GgX - LISP encapsulated
+						 * Do not check possible
+						 * encapsulation again.
+						 */
+#endif /* LISP */
+
 #ifdef __NO_STRICT_ALIGNMENT
 #define IP_HDR_ALIGNED_P(ip)	1
 #else
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/netinet/lisp/ip_lisp.c freebsd-10.1.0-LISP/sys/netinet/lisp/ip_lisp.c
--- freebsd-10.1.0-RELEASE/sys/netinet/lisp/ip_lisp.c	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/netinet/lisp/ip_lisp.c	2014-12-14 13:47:08.833169057 +0100
@@ -0,0 +1,1036 @@
+/*- /usr/src/sys/netinet/lisp/ip_lisp.c
+ *
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *
+ * $Id: ip_lisp.c 178 2011-09-22 14:50:11Z ggx $
+ *
+ */
+
+/*
+ * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1995
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)udp_usrreq.c	8.6 (Berkeley) 5/23/95
+ * $FreeBSD: src/sys/netinet/udp_usrreq.c,v 1.175.2.8 2006/10/06 20:26:06 andre Exp $
+ */
+
+#include "opt_ipfw.h"
+#include "opt_ipsec.h"
+#include "opt_inet6.h"
+#include "opt_mac.h"
+#include "opt_lisp.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/domain.h>
+#include <sys/eventhandler.h>
+#include <sys/jail.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/mac.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/proc.h>
+#include <sys/protosw.h>
+#include <sys/signalvar.h>
+#include <sys/socket.h>
+#include <sys/socketvar.h>
+#include <sys/sx.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <sys/syslog.h>
+
+#include <vm/uma.h>
+ 
+#include <net/if.h>
+#include <net/route.h>
+#include <net/netisr.h>
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/in_pcb.h>
+#include <netinet/in_var.h>
+#include <netinet/ip.h>
+#ifdef INET6
+#include <netinet/ip6.h>
+#endif
+#include <netinet/ip_icmp.h>
+#include <netinet/icmp_var.h>
+#include <netinet/ip_var.h>
+#ifdef INET6
+#include <netinet6/ip6_var.h>
+#endif
+#include <netinet/udp.h>
+#include <netinet/udp_var.h>
+
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+
+#include <netinet/lisp/ip_lisp.h>
+
+#include <netinet6/lisp6/ip6_lisp6.h>
+
+#include <machine/in_cksum.h>
+
+
+/* IPv4 Related Stats */
+struct  lispbasicstat lisp4stat;
+
+/* Link to IPv6 Stats variable */
+extern struct lispbasicstat lisp6stat;
+
+/* Sysctl Declarations specific to IPv4.
+ */
+
+SYSCTL_NODE(_net_inet, OID_AUTO, lisp, CTLFLAG_RW, 0, "IPv4 related LISP node");
+
+SYSCTL_STRUCT(_net_inet_lisp, OID_AUTO, stats, CTLFLAG_RW,
+	      &lisp4stat, lispbasicstat, 
+	      "LISP IPv4 stats (struct lispbasicstat, net/lisp/lisp.h)");
+
+
+extern  struct protosw inetsw[];
+
+
+int 
+lisp_ip_mapencap(struct mbuf ** m, int flags, struct eidmap ** local_map, struct eidmap ** remote_map)
+/*
+ * The function check if it exists in the mapping table a mapping 
+ * for the source EID and destination EID. 
+ * Function return 0 if no error is generated.
+ *
+ * If source EID mapping does not exist or is a negative mapping 
+ * both *local_map and *remote_map are returned as NULL. 
+ * The same if a source EID mapping exists but the mapping for the 
+ * destination EID is a negative mapping.
+ *
+ * Otherwise *local_map and *remote_map will contain pointer to an eidmap 
+ * structure containing the mapping.
+ *
+ * Note that in this latter case *remote_map can be NULL
+ * since it is just the case of a cache miss.
+ * Whether to do dataprobe or not is up to lisp_output (or the 
+ * consumer of the result).
+ */
+{
+        struct ip * ip = NULL;
+	struct eidmap * localmap = NULL;
+	struct eidmap * remotemap = NULL;
+	struct map_addrinfo info;
+	int err = 0;
+
+        if (flags & IP_LISP) {
+	       /* The packet has already been LISP-encapsulated:
+		*/
+	        return 0;
+	};
+
+	ip = mtod( (*m), struct ip *);
+
+       /* Source address validation */
+        if ( ip->ip_src.s_addr == INADDR_ANY ) {
+	       /* Source Address not yet defined, encapsulation not possible.
+		*/
+	        return 0;
+	};
+
+	localmap = malloc(sizeof(struct eidmap), M_TEMP, M_NOWAIT);
+	if ( !localmap ){
+	       /* No space to allocate buffers
+		*/
+	        return ENOBUFS;
+	};
+	    
+	bzero(localmap, sizeof(struct eidmap));
+	localmap->eid.ss_family = AF_INET;
+	localmap->eid.ss_len = sizeof(struct sockaddr_in);
+	((struct sockaddr_in *)&(localmap->eid))->sin_addr = ip->ip_src;
+
+	dblookup(localmap);
+
+	if (  localmap->mapping  &&
+	      !(localmap->mapping->map_flags & MAPF_NEGATIVE) && 
+	      !(IN_ARE_MASKED_ADDR_EQUAL(
+					 &(((struct sockaddr_in *)(map_key(localmap->mapping)))->sin_addr) ,
+					 &(((struct sockaddr_in *)(map_mask(localmap->mapping)))->sin_addr), 
+					 &(ip->ip_dst) ) ) ) { 
+
+
+	       /* There is a mapping for the source EID and
+		* destination is not in the same address range
+		* of source, thus now look for the 
+		* destination EID mapping.
+		*/
+
+	        remotemap = malloc(sizeof(struct eidmap), M_TEMP, M_NOWAIT);
+		if ( !remotemap ){
+		       /* No space to allocate buffers
+			*/
+
+		        FREE_EIDMAP(localmap);
+			return ENOBUFS;
+		};
+  			   
+	        bzero(remotemap, sizeof(struct eidmap));
+	        remotemap->eid.ss_family = AF_INET;
+  		remotemap->eid.ss_len = sizeof(struct sockaddr_in);
+		((struct sockaddr_in *)&(remotemap->eid))->sin_addr = ip->ip_dst;
+  
+		cachelookup(remotemap);
+
+		if (remotemap->mapping  == NULL) {
+		       /* If there is no mapping for the destination EID
+			* roll back like no mapping was present and
+			* notify a cache miss.
+			* Just leave the localmap to be used in the lisp_output
+			* in case dataprobe will ever be implemented.  
+			*/
+
+		        bzero(&info, sizeof(struct map_addrinfo));
+		        info.mapi_addrs |= MAPA_EID;
+			info.mapi_info[MAPX_EID] = (struct sockaddr_storage *)&(remotemap->eid);
+		        map_notifymsg(MAPM_MISS, &info, NULL, m, 0, &err);
+			      /*should check error condition*/
+
+		        free(remotemap, M_TEMP);
+			remotemap = NULL;
+
+		} else if (remotemap->mapping->map_flags & MAPF_NEGATIVE) { 
+		       /* There is a negative mapping rollback to 
+			* no mappings foud at all. This way ip_output 
+			* will try to forward the packet natively.
+			*/
+
+		        free(remotemap, M_TEMP);
+			remotemap = NULL;
+
+			free(localmap, M_TEMP);
+			localmap = NULL;
+
+		};
+
+	} else {
+	       /* No Local Mapping exists or it is a Negative Mapping
+		* free allocated buffer
+		*/
+	        free(localmap, M_TEMP);
+		localmap = NULL;
+
+	};
+
+	/* Hand back references to mappings. 
+	 */
+	*local_map = localmap;
+	*remote_map = remotemap;
+
+	return 0;
+
+} /* lisp_ip_mapencap() */
+
+
+int lisp_ip_needencap(register struct mbuf ** m)
+/*
+ * Check whether the packet should be LISP encapsulated.
+ * Means that it exists a local mapping for the source EID (addr).
+ * Returns 1 if it is the case otherwise 0. Error conditions 
+ * must be handled by the caller, usually ip_input().
+ */
+{
+ 
+         struct ip * ip = NULL;
+	 struct eidmap srcEID;
+
+	 KASSERT((m != NULL), "[lisp_ip_needencap] NULL mbuf!");
+
+	 if (( (*m) = m_pullup((*m), sizeof(struct ip))) == 0) {
+		        /* This should never happen due to previous check
+			 */
+		         return  0;
+			 
+	 };
+
+	 ip = mtod( (*m), struct ip *);
+
+	 /* Source address validation */
+	 if ( ip->ip_src.s_addr == INADDR_ANY ) {
+	        /* Source Address not yet defined, encapsulation not possible.
+		 */
+	         return 0;
+	 };
+
+
+	bzero(&srcEID, sizeof(struct eidmap));
+	srcEID.eid.ss_family = AF_INET;
+	srcEID.eid.ss_len = sizeof(struct sockaddr_in);
+	((struct sockaddr_in *)&(srcEID.eid))->sin_addr = ip->ip_src;
+
+	dblookup(&srcEID);
+  	  
+	if (srcEID.mapping) {
+
+	  if ( (IN_ARE_MASKED_ADDR_EQUAL(
+					 &(((struct sockaddr_in *)(map_key(srcEID.mapping)))->sin_addr) ,
+					 &(((struct sockaddr_in *)(map_mask(srcEID.mapping)))->sin_addr), 
+					 &(ip->ip_dst) ) ) ) { 
+
+		     /* GgX - Destination is in the same address range
+		      * of source, thus there is no need to encapsulate.
+		      */
+
+	    MAP_REMREF(srcEID.mapping);
+	    return 0;
+
+	  }; 
+
+
+	  MAP_REMREF(srcEID.mapping);
+	  return 1;
+	
+	};
+
+	 return 0;
+
+}  /* lisp_ip_needencap() */
+
+
+int lisp_ip_needdecap(register struct mbuf **m)
+/*
+ * Check whether the received packet is an IPv4 LISP packet.
+ * Means UDP + specific LISPDATA port number.
+ * Returns 1 if it is the case otherwise 0. Error conditions 
+ * must be handled by the caller, usually ip_input().
+ */
+{
+
+         struct ip * ip = NULL;
+	 struct udphdr * uh = NULL;
+
+	 KASSERT((m != NULL), "[lisp_ip_needdecap] NULL mbuf!");
+
+	 if ( m_length( (*m), NULL) < ( sizeof(struct ip) + 
+				     sizeof(struct udphdr) + 
+				     sizeof(struct lispshimhdr) ) ) {
+	       /* Packet is too short to be a LISP Packet 
+		*/  
+
+		return 0;
+
+	 };
+	      
+	 if ((*m)->m_len < sizeof(struct ip) + sizeof(struct udphdr)) {
+	   if (((*m) = m_pullup((*m), sizeof(struct ip) + sizeof(struct udphdr))) == 0) {
+		        /* This should never happen due to previous check
+			 */
+
+		         return  0;
+			 
+		 };
+
+	 };
+		
+	 ip = mtod((*m), struct ip *);
+	 
+	 if (inetsw[ip_protox[ip->ip_p]].pr_protocol == IPPROTO_UDP) {
+	        /* GgX - UDP packet destined to this machine  
+		 * remains to check the port number.
+		 */
+		  
+	         uh = (struct udphdr *)((caddr_t)ip + sizeof(struct ip));
+		 
+		 if (ntohs(uh->uh_dport) == LISPDATA) {
+		        /* Got a LISP packet
+			 */
+  		   
+		         return 1;
+  
+		 };
+		 
+	 };
+
+	 return 0;
+
+}  /* lisp_ip_needdecap() */
+
+
+
+int
+lisp_check_ip_mappings(register struct mbuf ** m, struct sockaddr_storage * drloc, struct sockaddr_storage * srloc, struct lispshimhdr * lisphdr)
+/* 
+ * Check if mappings for the received packet exists.
+ * Returns 0 if everything is ok. 
+ */
+{
+        struct eidmap local_map, remote_map; /* Will be zeroed later */
+	struct ip * ip = NULL;
+	struct locator * srcrloc = NULL;
+	struct locator * dstrloc = NULL;
+	struct map_addrinfo info;
+	int error = 0;
+	
+	/* Not necessary, but just in case
+	 */
+	(*m) = m_pullup((*m), sizeof(struct ip));
+
+	ip = mtod((*m), struct ip *);
+
+       /*
+	* Construct eidmap for local map.
+	* Stuff destination address in the structure.
+	*/
+
+        bzero(&local_map, sizeof(local_map));
+	local_map.eid.ss_family = AF_INET;
+	local_map.eid.ss_len = sizeof(struct sockaddr_in);
+	((struct sockaddr_in *)&local_map.eid)->sin_addr = ip->ip_dst;
+
+	/* Checkout for local mapping */
+	dblookup(&local_map); 	   
+
+	if (!local_map.mapping) {
+	      /* Received a LISP packet but this is not the 
+	       * correct ETR so drop it. 
+	       * The assumption is that local mappings are always present 
+	       * in the maptable, thus this is either an error or
+	       * a spoof.
+	       */
+
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[LISP_CHECK_IP_MAPPINGS] Drop! No Mapping in DB\n");
+#endif /* LISP_DEBUG */
+	  
+	       lisp4stat.ibadencap++;
+	       return(ENOENT);
+	};
+
+	if ( !(dstrloc = map_findrloc(local_map.mapping, drloc)) ) {
+	       /* RLOC not present in the mapping
+		* This should really never happen if the local mappings 
+		* are checked before insertion in the maptable.
+		* --- Panic?
+		*/
+
+	        MAP_REMREF(local_map.mapping);
+
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[LISP_CHECK_IP_MAPPINGS] Drop! No RLOC in DB Mapping\n");
+#endif /* LISP_DEBUG */
+
+		lisp4stat.ibadencap++;
+	        return(ENOATTR);
+	};
+		  
+	/*
+	 * Construct eidmap for remote map.
+	 * Stuff source address in the structure.
+	 */
+
+	bzero(&remote_map, sizeof(remote_map));
+	remote_map.eid.ss_family = AF_INET;
+	remote_map.eid.ss_len = sizeof(struct sockaddr_in);
+	((struct sockaddr_in *)&remote_map.eid)->sin_addr = ip->ip_src;
+
+
+	/* Checkout for mapping */
+	cachelookup(&remote_map); 	   
+
+	if (remote_map.mapping) {
+	       /* Got a mapping in the Cache
+		*/
+
+	        if ( !(srcrloc = map_findrloc(remote_map.mapping, srloc)) ) {
+		       /* RLOC not present in the mapping present in cache.
+			* --- Should send msg through map socket?
+			*/
+		  
+		        MAP_REMREF(local_map.mapping);
+			MAP_REMREF(remote_map.mapping);
+
+#ifdef LISP_DEBUG
+	                DEBUGLISP("[LISP_CHECK_IP_MAPPINGS] Drop! No RLOC Cache in Mapping\n");
+#endif /* LISP_DEBUG */
+
+			lisp4stat.ibadencap++;
+			return(ENOATTR);
+
+		};
+
+	} else {
+
+	       /* There is no mapping in the Cache.
+		* Behavior is now controlled by net.lisp.etr sysctl.
+		*/
+	  switch  (lispetr) {
+
+	  case LISP_ETR_SECURE:
+	         /* If no entry in the cache drop and notify
+		  */
+
+  	          bzero(&info, sizeof(struct map_addrinfo));
+		  info.mapi_addrs |= MAPA_EID;
+		  info.mapi_info[MAPX_EID] = ((struct sockaddr_storage *) &remote_map.eid);
+
+		 /* Fix IP header if necessary
+		  */
+		  if (lispmissmsg > LISP_MISSMSG_EID) {
+	
+	                  ip->ip_len = ntohs(ip->ip_len);
+			  ip->ip_off = ntohs(ip->ip_off);
+		    
+		  };
+
+		  map_notifymsg(MAPM_MISS, &info, NULL, m, 0, &error);
+		  /* Should check error condition*/
+
+		  MAP_REMREF(local_map.mapping);
+
+#ifdef LISP_DEBUG
+		  DEBUGLISP("[LISP_CHECK_IP_MAPPINGS] Drop! No Mapping in Cache\n");
+#endif /* LISP_DEBUG */
+
+		  lisp4stat.ibadencap++;
+		  return(ENOENT);
+
+		  break; /* XXX - Never reached */
+
+	  case LISP_ETR_NOTIFY:
+
+	         /* If no entry in the cache notify and forward
+		  */
+  	          bzero(&info, sizeof(struct map_addrinfo));
+		  info.mapi_addrs |= MAPA_EID;
+		  info.mapi_info[MAPX_EID] = ((struct sockaddr_storage *) &remote_map.eid);
+
+		 /* Fix IP header if necessary
+		  */
+		  if (lispmissmsg > LISP_MISSMSG_EID) {
+	
+	                  ip->ip_len = ntohs(ip->ip_len);
+			  ip->ip_off = ntohs(ip->ip_off);
+		    
+		  };
+
+		  map_notifymsg(MAPM_MISS, &info, NULL, m, 0, &error);
+		  /* Should check error condition*/
+
+
+		  /* Put IP header back to original state for re-injection
+		   */
+		  if (lispmissmsg > LISP_MISSMSG_EID) {
+	
+	                  ip->ip_len = htons(ip->ip_len);
+			  ip->ip_off = htons(ip->ip_off);
+		    
+		  };
+	    
+		  break;
+
+	  case LISP_ETR_STANDARD:
+	  default:
+	    /* Do nothing */
+	    ;
+
+	  };
+
+	};
+
+	if (check_lisphdr( lisphdr, local_map, remote_map, dstrloc, 
+			   srcrloc, &error)) {
+
+	        MAP_REMREF(local_map.mapping);
+
+	        if (remote_map.mapping) 
+		        MAP_REMREF(remote_map.mapping);
+	     
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[LISP_CHECK_IP_MAPPINGS] Drop! LISP Header\n");
+#endif /* LISP_DEBUG */
+
+		lisp4stat.ibadencap++;
+
+		if ( error == ELISP_SRCVNUMINVAL ) {
+		 
+		        lisp4stat.ibadsrcvnum++;
+
+		} else if ( error == ELISP_DSTVNUMINVAL ) {
+		 
+		        lisp4stat.ibaddstvnum++;
+
+		};
+
+		return(EINVAL);
+
+	};
+
+	MAP_REMREF(local_map.mapping);
+
+	if (remote_map.mapping)  
+	        MAP_REMREF(remote_map.mapping);
+
+	return 0; /* Everything's fine */
+
+}  /* lisp_check_ip_mappings() */
+
+
+int 
+lisp_ip_encap(struct mbuf ** m, int len, struct in_addr * srlocaddr, struct in_addr * drlocaddr, u_char ttl, uint16_t usport)
+{
+       /*
+	* Calculate data length and get a mbuf for UDP, 
+	* IP, and possible link-layer headers.  
+	* Immediate slide the data pointer back forward
+	* since we won't use that space at this layer.
+	*/
+  
+        struct udpiphdr * ui = NULL;        
+	struct ip * ip = NULL;
+  
+        M_PREPEND((*m), sizeof(struct udpiphdr) + max_linkhdr, M_DONTWAIT);
+
+	if ((*m) == NULL) {
+		return(ENOBUFS);
+	};
+
+	(*m)->m_data += max_linkhdr;
+	(*m)->m_len -= max_linkhdr;
+	(*m)->m_pkthdr.len -= max_linkhdr;
+
+       /*
+	* Fill in mbuf with extended UDP header
+	* and addresses and length put into network format.
+	*/
+	ui = mtod((*m), struct udpiphdr *);
+	bzero(ui->ui_x1, sizeof(ui->ui_x1));	/* XXX still needed? */
+	
+	ui->ui_pr = IPPROTO_UDP;
+	ui->ui_src = *srlocaddr;
+	ui->ui_dst = *drlocaddr;
+	ui->ui_sport = htons(usport);
+	ui->ui_dport = htons(LISPDATA);
+	ui->ui_ulen = htons((u_short)(len + sizeof(struct udphdr)) );
+
+       /*
+	* Set the Don't Fragment bit in the IP header.
+	*/
+	
+	ip = (struct ip *)&ui->ui_i;
+	ip->ip_off |= IP_DF;
+	ip->ip_off = htons(ip->ip_off);
+	
+	ui->ui_sum = 0;    /* LISP uses udp checksum = 0 */
+	(*m)->m_pkthdr.csum_flags &= ~CSUM_UDP;
+		
+	ip->ip_len = htons(sizeof (struct udpiphdr) + len);
+	ip->ip_ttl = ttl;	
+	ip->ip_tos = 0;	/* Default TOS */
+	ip->ip_v = IPVERSION;	
+
+        return(0);
+
+}  /* lisp_ip_encap() */
+
+
+
+void
+lisp_input(struct mbuf * m, int off)
+{
+
+  	int iphlen = off;
+	register struct ip *ip;
+	register struct udphdr *uh;
+	struct sockaddr_storage srloc,drloc;
+	int len;
+	u_char saved_ttl;
+	int error = 0;
+	int isr = 0;
+	uint16_t delta_ttl;
+	struct ip6_hdr * ip6 = NULL;
+	struct lispshimhdr rlisphdr;
+	
+	lisp4stat.ipackets++;
+	
+	/*
+	 * Get IP and UDP header together in first mbuf.
+	 */
+	ip = mtod(m, struct ip *);
+	if (m->m_len < (iphlen + sizeof(struct udphdr))) {
+		if ((m = m_pullup(m, iphlen + sizeof(struct udphdr))) == 0) {
+
+#ifdef LISP_DEBUG
+		        DEBUGLISP("[LISP_INPUT] Drop! Mbuf length smaller then IP + UDP header length \n");
+#endif /* LISP_DEBUG */
+			lisp4stat.ihdrops++;
+			goto lisp_input_drop;
+		}
+		ip = mtod(m, struct ip *);
+	}
+	uh = (struct udphdr *)((caddr_t)ip + iphlen);
+
+	/*
+	 * Strip outer IP+UDP header.
+	 * If not enough data to reflect minimum LISP inner packet length, drop.
+	 */
+
+	len = ntohs((u_short)uh->uh_ulen);
+
+	if (ip->ip_len != len) {
+	        if (len > ip->ip_len || 
+		    len < (sizeof(struct udphdr) + sizeof(struct lispshimhdr))) {
+			lisp4stat.ibadlen++;
+			goto lisp_input_drop;
+		}
+		m_adj(m, (len - ip->ip_len));
+
+	}
+
+	if (len <= (sizeof(struct udphdr) + sizeof(struct lispshimhdr) + sizeof(struct ip))) {
+
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[LISP_INPUT] Drop! Packet legth shorter than UDP + LISP + IP headers length \n");
+#endif /* LISP_DEBUG */
+
+  	        lisp4stat.ihdrops++;
+		goto lisp_input_drop;
+	}
+
+	/* Before really stripping the outer header save RLOCs for 
+	 * further checks.
+	 */
+	drloc.ss_family = srloc.ss_family = AF_INET;
+	drloc.ss_len = srloc.ss_len = sizeof(struct sockaddr_in);
+	((struct sockaddr_in *)&drloc)->sin_addr = ip->ip_dst;
+	((struct sockaddr_in *)&srloc)->sin_addr = ip->ip_src;
+
+	/* Save the value of the TTL in order to copy it back in the 
+	 * inner header.
+	 */
+
+	saved_ttl= ip->ip_ttl;
+
+	m_adj(m, (iphlen + sizeof(struct udphdr)));
+
+	m_copylisphdr(&m, &rlisphdr);
+
+
+	/*  Strip Lisp Shim Header */
+	m_adj(m, sizeof(struct lispshimhdr));
+
+	/* There is at least an IPv4 header XXXX */
+	   
+	m = m_pullup(m, sizeof(struct ip));
+	ip = mtod(m, struct ip *);
+
+	switch (ip->ip_v) {
+	
+	case IPVERSION:
+
+	        error = lisp_check_ip_mappings(&m, &drloc, &srloc, &rlisphdr); 
+		
+		if (error)  
+		        goto lisp_input_drop;
+
+		/* Everything went fine
+		 * Copy back the TTL and re-inject in the IP layer
+		 */
+		delta_ttl = ip->ip_ttl - saved_ttl;
+		ip->ip_ttl = saved_ttl;
+
+	       /* Update Checksum due to TTL recalculation 
+		*/
+		if (ip->ip_sum >= (u_int16_t) ~htons(delta_ttl << 8))
+		        ip->ip_sum -= ~htons(delta_ttl << 8);
+		else
+		        ip->ip_sum += htons(delta_ttl << 8);
+
+ 	        isr = NETISR_IP;
+
+		break;
+
+	case (IPV6_VERSION >> 4):
+
+	        lisp6stat.ioafpackets++;
+
+	        error = lisp_check_ip6_mappings(&m, &drloc, &srloc, &rlisphdr);
+
+		if (error)
+		        goto lisp_input_drop;
+
+		ip6 = mtod(m, struct ip6_hdr *);
+
+		ip6->ip6_hlim = saved_ttl;
+		
+ 	        isr = NETISR_IPV6;
+
+		break;
+
+	default:
+	  
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[LISP_INPUT] Drop! Unrecongnized inner packet AF\n");
+#endif /* LISP_DEBUG */
+
+	        lisp4stat.ihdrops++;
+	        goto lisp_input_drop;
+
+	};
+
+	netisr_dispatch(isr, m);
+
+	return;
+
+lisp_input_drop:
+
+	if (m)
+	        m_freem(m);
+
+	return;
+
+}    /* lisp_input() */
+
+
+int
+lisp_output(struct mbuf *m, int hlen, struct eidmap *local_map, struct eidmap *remote_map)
+{
+  	int len = m->m_pkthdr.len;
+	struct locator * srcrloc;
+	struct locator * dstrloc;
+	int error = 0;
+	u_char saved_ttl;
+	uint16_t usrcport;
+
+	struct ip *ip = mtod(m, struct ip *);
+
+
+	KASSERT(local_map->mapping,"[LISP_OUTPUT] LISP output without local mapping");
+	KASSERT(m, "[LISP_OUTPUT] Output without packet");
+
+	if (remote_map  == NULL)  {
+	       /* There is no mapping for the destination EID.
+		* Do not set error, so that we silently drop
+		*/
+
+	        lisp4stat.omissdrops++;
+		goto lisp_output_drop;
+		 
+	};
+
+
+	/* Fix the IP header before going further, then 
+	 * encapsulate.
+	 */
+	
+	if (m->m_pkthdr.csum_flags & CSUM_DELAY_DATA) {
+	        in_delayed_cksum(m);
+		m->m_pkthdr.csum_flags &= ~CSUM_DELAY_DATA;
+	};
+  	
+	ip->ip_sum = 0;
+	ip->ip_sum = in_cksum(m, hlen);
+       
+
+	/* Save original TTL value to copy it back in the new outer header.
+	 */
+	saved_ttl = ip->ip_ttl;
+
+	/* Destination RLOC selection 
+	 */
+	if ((error = map_select_dstrloc(remote_map->mapping, &dstrloc))){
+	       /* There is no available RLOC that can be used 
+		*/
+
+	        lisp4stat.onorlocdrops++;
+	        goto lisp_output_drop;
+	};
+
+	/* If the MTU of the destination locator is set a check on 
+	 * the size is performed.
+	 */
+	if (dstrloc->rloc_metrix.rlocmtx.mtu &&
+	    ((len + sizeof(struct udphdr) + 
+	      SIZEOF_IPHDR(dstrloc->rloc_addr->ss_family) +
+	      sizeof(struct lispshimhdr)) > dstrloc->rloc_metrix.rlocmtx.mtu)) {
+		  
+	        error = EMSGSIZE;
+	        lisp4stat.osizedrops++;
+		goto lisp_output_drop;
+
+	};
+		
+
+	/* Source RLOC selection 
+	 * Must match the destination RLOC AF (drloc_af)
+	 * and also be the address of the interface through which 
+	 * the packet will be sent 
+	 */
+	if ((error = map_select_srcrloc(local_map->mapping, dstrloc, 
+					&srcrloc))) {
+	       /* There is no available source RLOC that can be used 
+		*/
+
+	        lisp4stat.onorlocdrops++;
+	        goto lisp_output_drop;
+
+	};
+
+	/* If the MTU of the source locator is set a check on the size
+	 * is performed.
+	 */
+	if (srcrloc->rloc_metrix.rlocmtx.mtu &&
+	    ((len + sizeof(struct udphdr) + 
+	      SIZEOF_IPHDR(srcrloc->rloc_addr->ss_family) + 
+	      sizeof(struct lispshimhdr)) > srcrloc->rloc_metrix.rlocmtx.mtu)) {
+
+		error = EMSGSIZE;
+	        lisp4stat.osizedrops++;
+		goto lisp_output_drop;
+
+	};
+
+	/* Global IPv4 MTU check 
+	 */
+	if (len + sizeof(struct udphdr) + 
+	    SIZEOF_IPHDR(srcrloc->rloc_addr->ss_family) +
+	    sizeof(struct lispshimhdr) > IP_MAXPACKET) {
+
+		error = EMSGSIZE;
+		lisp4stat.osizedrops++;
+		goto lisp_output_drop;
+
+	};
+
+	/* Ready to encapsulate.
+	 * Before do it let's calculate the src port
+	 * Src port is hash based on the inner header.
+	 */
+
+	usrcport = get_lisp_srcport(&m);
+
+	m = m_lisphdrprepend(m, remote_map, local_map, dstrloc, srcrloc);
+
+	if (m == NULL) {
+
+		error = ENOBUFS;
+	        lisp4stat.onobufdrops++;
+		goto lisp_output_drop;
+
+	};
+
+	switch (srcrloc->rloc_addr->ss_family) {
+	  
+	        case AF_INET:	 
+	
+		        if ( !(error = lisp_ip_encap(&m, (len + sizeof(struct lispshimhdr)), 
+						     &((struct sockaddr_in *)srcrloc->rloc_addr)->sin_addr, 	     
+						     &((struct sockaddr_in *)dstrloc->rloc_addr)->sin_addr, 
+						     saved_ttl,
+						     usrcport))){
+			
+		                lisp4stat.opackets++;
+				error = ip_output(m, NULL, NULL, IP_LISP, NULL, NULL);
+
+			};
+			
+			FREE_EIDMAP(local_map);
+		        FREE_EIDMAP(remote_map);
+
+			return (error);
+			
+			break;
+	
+                 case AF_INET6:
+
+		        lisp6stat.ooafpackets++;
+
+		        if ( !(error = lisp_ip6_encap(&m, (len + sizeof(struct lispshimhdr)),
+						     &((struct sockaddr_in6 *)srcrloc->rloc_addr)->sin6_addr, 	     
+						     &((struct sockaddr_in6 *)dstrloc->rloc_addr)->sin6_addr, 
+						      ((int)saved_ttl),
+						      usrcport))) {
+			
+		                lisp6stat.opackets++;
+				error = ip6_output(m, NULL, NULL, IP_LISP, NULL, NULL, NULL);
+
+			};
+
+			FREE_EIDMAP(local_map);
+		        FREE_EIDMAP(remote_map);
+
+			return(error);
+
+			break;
+
+	         default:
+		        error = EPFNOSUPPORT;
+
+	};  
+
+
+
+lisp_output_drop:
+
+	if (remote_map) {
+	        FREE_EIDMAP(remote_map);
+	};
+
+	FREE_EIDMAP(local_map);
+  
+	m_freem(m);
+	
+	lisp4stat.odrops++;
+	lisp4stat.opackets++;
+
+	return (error);
+
+}   /* lisp_output() */
+
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/netinet/lisp/ip_lisp.h freebsd-10.1.0-LISP/sys/netinet/lisp/ip_lisp.h
--- freebsd-10.1.0-RELEASE/sys/netinet/lisp/ip_lisp.h	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/netinet/lisp/ip_lisp.h	2014-12-14 13:47:08.833169057 +0100
@@ -0,0 +1,57 @@
+/*- /usr/src/sys/netinet/lisp/ip_lisp.h
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *
+ * $Id: ip_lisp.h 178 2011-09-22 14:50:11Z ggx $
+ *
+ */
+
+#ifndef _IP_LISP_H_
+#define _IP_LISP_H_
+
+#define IN_ARE_MASKED_ADDR_EQUAL(a, b, c)		\
+  ((a)->s_addr == ((b)->s_addr & (c)->s_addr))
+
+
+int lisp_check_ip_mappings(struct mbuf **, struct sockaddr_storage *,
+			   struct sockaddr_storage *, struct lispshimhdr *);
+
+int lisp_ip_encap(struct mbuf **, int, struct in_addr *, struct in_addr *, 
+		  u_char, uint16_t);
+
+int lisp_ip_needencap(struct mbuf **);
+int lisp_ip_needdecap(struct mbuf **);
+
+int lisp_ip_mapencap(struct mbuf **, int, struct eidmap **, struct eidmap **);
+
+void	lisp_input(struct mbuf *, int);
+int     lisp_output(struct mbuf *, int, struct eidmap *, struct eidmap*);
+
+#endif /*_IP_LISP_H_*/
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/netinet6/ip6_forward.c freebsd-10.1.0-LISP/sys/netinet6/ip6_forward.c
--- freebsd-10.1.0-RELEASE/sys/netinet6/ip6_forward.c	2014-12-05 22:07:23.907159365 +0100
+++ freebsd-10.1.0-LISP/sys/netinet6/ip6_forward.c	2014-12-14 13:47:08.833169057 +0100
@@ -37,6 +37,7 @@
 #include "opt_ipfw.h"
 #include "opt_ipsec.h"
 #include "opt_ipstealth.h"
+#include "opt_lisp.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -67,6 +68,12 @@
 #include <netinet/icmp6.h>
 #include <netinet6/nd6.h>
 
+#ifdef LISP
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+#include <netinet6/lisp6/ip6_lisp6.h>
+#endif /* LISP */
+
 #include <netinet/in_pcb.h>
 
 #ifdef IPSEC
@@ -111,6 +118,11 @@
 	struct m_tag *fwd_tag;
 	char ip6bufs[INET6_ADDRSTRLEN], ip6bufd[INET6_ADDRSTRLEN];
 
+#ifdef LISP
+	struct eidmap *local_map = NULL;
+	struct eidmap *remote_map = NULL;
+#endif /* LISP */
+
 #ifdef IPSEC
 	/*
 	 * Check AH/ESP integrity.
@@ -358,6 +370,25 @@
 	dst->sin6_family = AF_INET6;
 	dst->sin6_addr = ip6->ip6_dst;
 again2:
+#ifdef LISP
+	/* Check if LISP encap possible.
+	 * If possible call the correct routine.
+	 */
+
+	error = 0;
+
+	if ( !srcrt && ((error = lisp_ip6_mapencap(&m, 0, &local_map,
+						   &remote_map)) == 0)
+	            && local_map ) {
+		error = lisp6_output(m, sizeof(struct ip6_hdr), 
+					      local_map, remote_map);
+		goto freecopy; 
+	} else if (error) {
+		m_freem(m);
+		goto freecopy;
+	};
+#endif /* LISP */
+
 	rin6.ro_rt = in6_rtalloc1((struct sockaddr *)dst, 0, 0, M_GETFIB(m));
 	if (rin6.ro_rt != NULL)
 		RT_UNLOCK(rin6.ro_rt);
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/netinet6/ip6_input.c freebsd-10.1.0-LISP/sys/netinet6/ip6_input.c
--- freebsd-10.1.0-RELEASE/sys/netinet6/ip6_input.c	2014-12-05 22:07:22.374393353 +0100
+++ freebsd-10.1.0-LISP/sys/netinet6/ip6_input.c	2014-12-14 13:47:08.837171059 +0100
@@ -69,6 +69,7 @@
 #include "opt_ipsec.h"
 #include "opt_kdtrace.h"
 #include "opt_route.h"
+#include "opt_lisp.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -111,6 +112,12 @@
 #include <netinet6/in6_ifattach.h>
 #include <netinet6/nd6.h>
 
+#ifdef LISP 
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+#include <netinet6/lisp6/ip6_lisp6.h>
+#endif /* LISP */
+
 #ifdef IPSEC
 #include <netipsec/ipsec.h>
 #include <netinet6/ip6_ipsec.h>
@@ -1016,6 +1023,16 @@
 		if (nxt == IPPROTO_ICMPV6 && rtalert != ~0)
 			m->m_flags |= M_RTALERT_MLD;
 
+#ifdef LISP
+                /* 
+		 * Check if the packet is LISP encapsulated. If so 
+                 * it is diverted to the lisp6_input() routine.
+                 */
+
+		if (lisp_ip6_needdecap(&m, off, nxt))
+                        nxt = lisp6_input(&m, &off, nxt);
+                else 
+#endif /* LISP */
 		nxt = (*inet6sw[ip6_protox[nxt]].pr_input)(&m, &off, nxt);
 	}
 	goto out;
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/netinet6/ip6_output.c freebsd-10.1.0-LISP/sys/netinet6/ip6_output.c
--- freebsd-10.1.0-RELEASE/sys/netinet6/ip6_output.c	2014-12-05 22:07:22.378395353 +0100
+++ freebsd-10.1.0-LISP/sys/netinet6/ip6_output.c	2014-12-14 13:47:08.845175059 +0100
@@ -69,6 +69,7 @@
 #include "opt_ipsec.h"
 #include "opt_sctp.h"
 #include "opt_route.h"
+#include "opt_lisp.h"
 
 #include <sys/param.h>
 #include <sys/kernel.h>
@@ -92,6 +93,10 @@
 #include <net/vnet.h>
 
 #include <netinet/in.h>
+#ifdef LISP
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#endif /* LISP */
 #include <netinet/in_var.h>
 #include <netinet/ip_var.h>
 #include <netinet6/in6_var.h>
@@ -102,6 +107,12 @@
 #include <netinet/tcp_var.h>
 #include <netinet6/nd6.h>
 
+#ifdef LISP
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+#include <netinet6/lisp6/ip6_lisp6.h>
+#endif /* LISP */
+
 #ifdef IPSEC
 #include <netipsec/ipsec.h>
 #include <netipsec/ipsec6.h>
@@ -258,6 +269,10 @@
 	struct secpolicy *sp = NULL;
 #endif /* IPSEC */
 	struct m_tag *fwd_tag = NULL;
+#ifdef LISP
+        struct eidmap *local_map = NULL;
+        struct eidmap *remote_map = NULL;
+#endif /* LISP */
 
 	ip6 = mtod(m, struct ip6_hdr *);
 	if (ip6 == NULL) {
@@ -509,6 +524,27 @@
 
 	IP6STAT_INC(ip6s_localout);
 
+#ifdef LISP
+	/*  
+	 * Before perform normal routing check if we have to
+	 * perform LISP encapsulation.
+	 * If no encapsulation is possible we continue with 
+	 * "traditional" operation (kind of fall-back 
+	 * approach.
+	 */
+
+	hlen = sizeof(struct ip6_hdr); /* XXX - Be sure hlen is initialized */
+
+	if ( ((error = lisp_ip6_mapencap(&m, flags, &local_map,
+					 &remote_map)) == 0)
+		&& local_map ) {
+		error = lisp6_output(m, hlen, local_map, remote_map);
+		goto done; 
+	} else if (error) {
+		goto bad;
+	};
+#endif /* LISP */
+
 	/*
 	 * Route packet.
 	 */
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/netinet6/lisp6/ip6_lisp6.c freebsd-10.1.0-LISP/sys/netinet6/lisp6/ip6_lisp6.c
--- freebsd-10.1.0-RELEASE/sys/netinet6/lisp6/ip6_lisp6.c	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/netinet6/lisp6/ip6_lisp6.c	2014-12-14 13:47:08.845175059 +0100
@@ -0,0 +1,890 @@
+/*- /usr/src/sys/netinet6/lisp6/ip6_lisp6.c
+ *
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *
+ * $Id: ip6_lisp6.c 178 2011-09-22 14:50:11Z ggx $
+ *
+ */
+
+#include "opt_inet.h"
+#include "opt_inet6.h"
+#include "opt_lisp.h"
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/mbuf.h>
+#include <sys/priv.h>
+#include <sys/proc.h>
+#include <sys/protosw.h>
+#include <sys/signalvar.h>
+#include <sys/socket.h>
+#include <sys/socketvar.h>
+#include <sys/sx.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <sys/syslog.h>
+#include <sys/systm.h>
+
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/route.h>
+#include <net/netisr.h>
+
+#include <netinet/in.h>
+#include <net/lisp/lisp.h>
+#include <net/lisp/maptables.h>
+#include <netinet/in_pcb.h>
+#include <netinet/in_systm.h>
+#include <netinet/in_var.h>
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+#include <netinet/ip_icmp.h>
+#include <netinet/ip6.h>
+#include <netinet/icmp_var.h>
+#include <netinet/icmp6.h>
+#include <netinet/udp.h>
+#include <netinet/udp_var.h>
+#include <netinet/lisp/ip_lisp.h>
+
+#include <netinet6/ip6protosw.h>
+#include <netinet6/ip6_var.h>
+#include <netinet6/in6_pcb.h>
+#include <netinet6/udp6_var.h>
+#include <netinet6/scope6_var.h>
+#include <netinet6/lisp6/ip6_lisp6.h>
+
+/*
+ * LISP protocol implementation for IPv6 encap/decap.
+ */
+
+/* IPv6 Related Stats */
+struct  lispbasicstat lisp6stat;
+
+/* Link to IPv4 Stats variable */
+extern struct lispbasicstat lisp4stat;
+
+/* Sysctl Declarations
+ */
+
+#ifdef SYSCTL_DECL
+SYSCTL_DECL(_net_inet6);
+#endif /* SYSCTL_DECL */
+
+SYSCTL_NODE(_net_inet6, OID_AUTO, lisp, CTLFLAG_RW, 0, "IPv6 related LISP node");
+
+SYSCTL_STRUCT(_net_inet6_lisp, OID_AUTO, stats, CTLFLAG_RW,
+	      &lisp6stat, lispbasicstat, 
+	      "LISP IPv6 stats (struct lispbasicstat, net/lisp/lisp.h)");
+
+
+int 
+lisp_ip6_mapencap(struct mbuf ** m, int flags, struct eidmap ** local_map, struct eidmap ** remote_map)
+/*
+ * The function check if it exists in the mapping table a mapping 
+ * for the source EID and destination EID. 
+ * Function return 0 if no error is generated.
+ *
+ * If source EID mapping does not exist or is a negative mapping 
+ * both *local_map and *remote_map are returned as NULL. 
+ * The same if a source EID mapping exists but the mapping for the 
+ * destination EID is a negative mapping.
+ *
+ * Otherwise *local_map and *remote_map will contain pointer to an eidmap 
+ * structure containing the mapping.
+ *
+ * Note that in this latter case *remote_map can be NULL
+ * since it is just the case of a cache miss.
+ * Whether to do dataprobe or not is up to lisp6_output (or the 
+ * consumer of the result).
+ */
+{
+        struct ip6_hdr * ip6 = NULL;
+	struct eidmap * localmap = NULL;
+	struct eidmap * remotemap = NULL;
+	struct map_addrinfo info;
+	int err = 0;
+	
+        if (flags & IP_LISP) {
+	       /* The packet has already been LISP-encapsulated:
+		*/
+	        return 0;
+	};
+
+	ip6 = mtod((*m), struct ip6_hdr *);
+
+       /* Source address validation */
+        if (IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_src) &&
+	    (flags & IPV6_UNSPECSRC) == 0) {
+	       /* Source Address not yet defined, encapsulation not 
+		* possible.
+		*/
+
+	        return 0;
+        };
+
+	localmap = malloc(sizeof(struct eidmap), M_TEMP, M_NOWAIT);
+	if ( !localmap ){
+	       /* No space to allocate buffers
+		*/
+	        return ENOBUFS;
+	};
+
+	bzero(localmap, sizeof(struct eidmap));
+	localmap->eid.ss_family = AF_INET6;
+	localmap->eid.ss_len = sizeof(struct sockaddr_in6);
+	((struct sockaddr_in6 *)&(localmap->eid))->sin6_addr = ip6->ip6_src;
+
+	dblookup(localmap);
+  	  
+	if (localmap->mapping  &&
+	    !(localmap->mapping->map_flags & MAPF_NEGATIVE) && 
+	    !IN6_ARE_MASKED_ADDR_EQUAL(
+					 &(((struct sockaddr_in6 *)(map_key(localmap->mapping)))->sin6_addr) ,  &(ip6->ip6_dst),
+
+					 &(((struct sockaddr_in6 *)(map_mask(localmap->mapping)))->sin6_addr) )) { 
+
+	       /* There is a mapping for the source EID and
+		* destination is not in the same address range
+		* of source, thus now look for the 
+		* destination EID mapping.
+		*/
+
+	        remotemap = malloc(sizeof(struct eidmap), M_TEMP, M_NOWAIT);
+		if ( !remotemap ){
+		       /* No space to allocate buffers
+			*/
+
+		        FREE_EIDMAP(localmap);
+			return ENOBUFS;
+		};
+  			   
+	        bzero(remotemap, sizeof(struct eidmap));
+	        remotemap->eid.ss_family = AF_INET6;
+  		remotemap->eid.ss_len = sizeof(struct sockaddr_in6);
+		((struct sockaddr_in6 *)&(remotemap->eid))->sin6_addr = ip6->ip6_dst;
+  
+		cachelookup(remotemap);
+
+		if (remotemap->mapping  == NULL)  {
+		       /* If there is no mapping for the destination EID
+			* roll back like no mapping was present and
+			* notify a cache miss.
+			* Just leave the localmap to be used in the lisp_output
+			* in case dataprobe will ever be implemented.  
+			*/
+
+		        bzero(&info, sizeof(struct map_addrinfo));
+		        info.mapi_addrs |= MAPA_EID;
+			info.mapi_info[MAPX_EID] = (struct sockaddr_storage *)&(remotemap->eid);
+		        map_notifymsg(MAPM_MISS, &info, NULL, m, 0, &err);
+			      /*should check error condition*/
+
+		        free(remotemap, M_TEMP);
+			remotemap = NULL;
+
+		} else if (remotemap->mapping->map_flags & MAPF_NEGATIVE) { 
+		       /* There is a negative mapping rollback to 
+			* no mappings foud at all. This way ip_output 
+			* will try to forward the packet natively.
+			*/
+
+		        free(remotemap, M_TEMP);
+			remotemap = NULL;
+
+			free(localmap, M_TEMP);
+			localmap = NULL;
+
+		};
+
+	} else {
+	       /* No Local Mapping exists free allocated buffer
+		*/
+	        free(localmap, M_TEMP);
+		localmap = NULL;
+
+	};
+
+	/* Hand back references to mappings. 
+	 */
+	*local_map = localmap;
+	*remote_map = remotemap;
+
+	return 0;
+
+} /* lisp_ip6_mapencap() */
+
+
+int 
+lisp_ip6_needdecap(register struct mbuf **m, int off, int proto)
+{
+        /* Check whether the received packet is an IPv6 LISP packet.
+	 * Means UDP + specific LISPDATA port number.
+	 * Returns 1 if it is the case otherwise 0. Error conditions 
+	 * must be handled by the caller, usually ip6_input().
+	 */
+
+	struct udphdr *uh;
+	struct ip6_hdr *ip6;
+
+	if (proto != IPPROTO_UDP) {
+	       /* It is not UDP packet, thus not a LISP packet 
+		*/
+	       return 0;
+	};
+
+#ifndef PULLDOWN_TEST
+	IP6_EXTHDR_CHECK((*m), off, sizeof(struct udphdr), IPPROTO_DONE);
+	ip6 = mtod((*m), struct ip6_hdr *);
+	uh = (struct udphdr *)((caddr_t)ip6 + off);
+#else	
+
+	IP6_EXTHDR_GET(uh, struct udphdr *, (*m), off, sizeof(*uh));
+        if (!uh) {
+                 return 0;
+	};
+#endif /*PULLDOWN_TEST */
+
+	if (ntohs(uh->uh_dport) == LISPDATA) {
+	       /* Got a LISP packet
+		*/
+	        return 1;
+	};
+
+	return 0;
+
+}  /* lisp__ip6_needdecap() */
+
+
+int
+lisp_check_ip6_mappings(register struct mbuf ** m, struct sockaddr_storage * drloc, struct sockaddr_storage * srloc, struct lispshimhdr * lisphdr)
+{
+	struct eidmap local_map, remote_map;
+	struct ip6_hdr * ip6 = NULL;
+	struct locator * srcrloc = NULL;
+	struct locator * dstrloc = NULL;
+	struct map_addrinfo info;
+	int error = 0;
+	
+       /* Not necessary, but just in case
+	*/
+	(*m) = m_pullup((*m), sizeof(struct ip6_hdr));
+
+	ip6 = mtod((*m), struct ip6_hdr *);
+
+       /*
+	* Construct eidmap for local map.
+	* Stuff source address in the structure.
+	*/
+
+        bzero(&local_map, sizeof(local_map));
+	local_map.eid.ss_family = AF_INET6;
+	local_map.eid.ss_len = sizeof(struct sockaddr_in6);
+	((struct sockaddr_in6 *)&local_map.eid)->sin6_addr = ip6->ip6_dst;
+
+	/* Checkout for local mapping */
+	dblookup(&local_map); 	   
+
+	if (!local_map.mapping) {
+	      /* Received a LISP packet but this is not the 
+	       * correct ETR so drop it. 
+	       * We assume that local mapping are always present 
+	       * in the maptable, thus this is either an error or
+	       * a spoof.
+	       */
+		  
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[LISP_CHECK_IP6_MAPPINGS] Drop! No Mapping in DB\n");
+#endif /* LISP_DEBUG */
+
+	       lisp6stat.ibadencap++;
+	       return(ENOENT);
+	};
+
+	if ( !(dstrloc = map_findrloc(local_map.mapping, drloc)) ) {
+	       /* RLOC not present in the mapping
+		* This should really never happen if the local mappings 
+		* are checked before insertion in the maptable.
+		* --- Panic?
+		*/
+
+	        MAP_REMREF(local_map.mapping);
+
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[LISP_CHECK_IP6_MAPPINGS] Drop! No RLOC in DB Mapping\n");
+#endif /* LISP_DEBUG */
+
+		lisp6stat.ibadencap++;
+	        return(ENOATTR);
+	};
+		  
+	/*
+	 * Construct eidmap for remote map.
+	 * Stuff source address in the structure.
+	 */
+
+	bzero(&remote_map, sizeof(remote_map));
+	remote_map.eid.ss_family = AF_INET6;
+	remote_map.eid.ss_len = sizeof(struct sockaddr_in6);
+	((struct sockaddr_in6 *)&remote_map.eid)->sin6_addr = ip6->ip6_src;
+
+
+	/* Checkout for mapping */
+	cachelookup(&remote_map); 	   
+
+	if (remote_map.mapping) {
+	       /* Got a mapping in the Cache
+		*/
+
+	        if ( !(srcrloc = map_findrloc(remote_map.mapping, srloc)) ) {
+		       /* RLOC not present in the mapping present in cache.
+			* --- Should send msg through map socket?
+			*/
+		  
+		        MAP_REMREF(local_map.mapping);
+			MAP_REMREF(remote_map.mapping);
+
+#ifdef LISP_DEBUG
+	                DEBUGLISP("[LISP_CHECK_IP6_MAPPINGS] Drop! No RLOC Cache in Mapping\n");
+#endif /* LISP_DEBUG */
+
+			lisp6stat.ibadencap++;
+			return(ENOATTR);
+
+		};
+
+	} else {
+
+	       /* There is no mapping in the Cache.
+		* Behavior is now controlled by net.lisp.etr sysctl.
+		*/
+	  switch  (lispetr) {
+
+	  case LISP_ETR_SECURE:
+	         /* If no entry in the cache drop and notify
+		  */
+
+  	          bzero(&info, sizeof(struct map_addrinfo));
+		  info.mapi_addrs |= MAPA_EID;
+		  info.mapi_info[MAPX_EID] = ((struct sockaddr_storage *) &remote_map.eid);
+
+		  map_notifymsg(MAPM_MISS, &info, NULL, m, 0, &error);
+		  /* Should check error condition*/
+
+		  MAP_REMREF(local_map.mapping);
+
+#ifdef LISP_DEBUG
+		  DEBUGLISP("[LISP_CHECK_IP6_MAPPINGS] Drop! No Mapping in Cache\n");
+#endif /* LISP_DEBUG */
+
+		  lisp6stat.ibadencap++;
+		  return(ENOENT);
+
+		  break; /* XXX - Never reached */
+
+	  case LISP_ETR_NOTIFY:
+
+	         /* If no entry in the cache notify and forward
+		  */
+  	          bzero(&info, sizeof(struct map_addrinfo));
+		  info.mapi_addrs |= MAPA_EID;
+		  info.mapi_info[MAPX_EID] = ((struct sockaddr_storage *) &remote_map.eid);
+
+		  map_notifymsg(MAPM_MISS, &info, NULL, m, 0, &error);
+		  /* Should check error condition*/
+
+		  break;
+
+	  case LISP_ETR_STANDARD:
+	  default:
+	    /* Do nothing */
+	    ;
+
+	  };
+
+	};
+
+
+
+	if (check_lisphdr( lisphdr, local_map, remote_map, dstrloc, 
+			   srcrloc, &error)) {
+
+	        MAP_REMREF(local_map.mapping);
+
+	        if (remote_map.mapping) 
+		        MAP_REMREF(remote_map.mapping);
+	     
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[LISP_CHECK_IP_MAPPINGS] Drop! LISP Header\n");
+#endif /* LISP_DEBUG */
+
+		lisp6stat.ibadencap++;
+
+		if ( error == ELISP_SRCVNUMINVAL ) {
+		 
+		        lisp6stat.ibadsrcvnum++;
+
+		} else if ( error == ELISP_DSTVNUMINVAL ) {
+		 
+		        lisp6stat.ibaddstvnum++;
+
+		};
+
+		return(EINVAL);
+
+	};
+
+	MAP_REMREF(local_map.mapping);
+
+	if (remote_map.mapping)  
+	        MAP_REMREF(remote_map.mapping);
+
+	return 0; /* Everything's fine */
+
+}  /* lisp_check_ip6_mappings() */
+
+
+int 
+lisp_ip6_encap(struct mbuf ** m, int len, struct in6_addr * srlocaddr, struct in6_addr * drlocaddr, int hlim, uint16_t usport)
+{
+	/*
+	 * Calculate data length and get a mbuf for UDP, 
+	 * IP, and possible link-layer headers.  
+	 * Immediate slide the data pointer back forward
+	 * since we won't use that space at this layer.
+	 */
+  
+	uint32_t ulen = (*m)->m_pkthdr.len;
+	uint32_t plen = sizeof(struct udphdr) + ulen;        
+	struct udphdr * uh = NULL;        
+	struct ip6_hdr * ip6 = NULL;
+ 
+	M_PREPEND((*m), sizeof(struct ip6_hdr) + 
+		  sizeof(struct udphdr), M_DONTWAIT);
+
+	if ((*m) == 0) {
+	        return(ENOBUFS);
+	};
+
+	/*
+	 * Stuff UDP Header.
+	 */
+
+	uh = (struct udphdr *)(mtod((*m), caddr_t) + sizeof(struct ip6_hdr));
+	uh->uh_sport = htons(usport);
+ 	uh->uh_dport = htons(LISPDATA);
+	uh->uh_ulen = htons((u_short)plen);
+
+	uh->uh_sum = 0;    /* LISP uses udp checksum = 0 */
+	(*m)->m_pkthdr.csum_flags &= ~CSUM_UDP;
+
+
+	/*
+	 * Stuff IPv6 Header.
+	 */
+
+	ip6 = mtod((*m), struct ip6_hdr *);
+
+	ip6->ip6_flow	=  0 & IPV6_FLOWINFO_MASK;
+       /* GgX:
+	* draft-ietf-lisp-04.txt does not specify values
+	* to be used for the "Traffic Class" and the "Flow Label"
+	* fields. 
+	* 
+	* We just set them to 0.
+	*
+	* Note also that copy these information from the inner header 
+	* works only in the case of IPv6-over-IPv6. Furthermore,
+	* copying back these information can raise similar problems
+	* like in the udp source port, when a state-full firewall is 
+	* present.
+	*   
+	*/
+
+	ip6->ip6_vfc	&= ~IPV6_VERSION_MASK;
+	ip6->ip6_vfc	|= IPV6_VERSION;
+
+	ip6->ip6_plen	= htons((u_short)(*m)->m_pkthdr.len);
+
+	ip6->ip6_nxt	= IPPROTO_UDP;
+	ip6->ip6_hlim	= hlim;
+	ip6->ip6_src	= *srlocaddr;
+	ip6->ip6_dst	= *drlocaddr;
+
+        return(0);
+
+}  /* lisp_ip6_encap() */
+
+
+
+
+int
+lisp6_input(struct mbuf **mp, int *offp, int proto)
+{
+  	struct mbuf *m = *mp;
+	int off = *offp;
+	struct ip6_hdr *ip6;
+	struct udphdr *uh;
+	int plen, ulen, saved_hlim;
+	struct sockaddr_storage srloc,drloc;
+	struct ip * ip = NULL;
+	int error = 0;  
+	int isr = 0;
+	uint16_t delta_ttl;
+	struct lispshimhdr rlisphdr;
+
+	lisp6stat.ipackets++;
+
+	ip6 = mtod(m, struct ip6_hdr *);
+ 
+#ifndef PULLDOWN_TEST
+	IP6_EXTHDR_CHECK(m, off, sizeof(struct udphdr), IPPROTO_DONE);
+	ip6 = mtod(m, struct ip6_hdr *);
+	uh = (struct udphdr *)((caddr_t)ip6 + off);
+#else
+	IP6_EXTHDR_GET(uh, struct udphdr *, m, off, sizeof(*uh));
+	if (!uh)
+		return (IPPROTO_DONE);
+#endif
+
+	plen = ntohs(ip6->ip6_plen) - off + sizeof(struct ip6_hdr);
+	ulen = ntohs((u_short)uh->uh_ulen);
+	
+	/* This is used for packet length check assuming that there is at 
+	 * least an IPv4 header inside the encapsulation.
+	 */
+
+	if (plen != ulen) {
+  	        lisp6stat.ibadlen++;
+		goto lisp6_input_drop;
+	}
+
+
+	if (ulen <= (sizeof(struct udphdr) + sizeof(struct lispshimhdr) 
+		     + sizeof(struct ip))) {
+
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[LISP6_INPUT] Drop! Packet legth shorter than UDP + LISP + IP headers length \n");
+#endif /* LISP_DEBUG */
+
+  	        lisp6stat.ihdrops++;
+		goto lisp6_input_drop;
+	}
+
+	/* Before really stripping the outer header save RLOCs for 
+	 * further checks.
+	 */
+	drloc.ss_family = srloc.ss_family = AF_INET6;
+	drloc.ss_len = srloc.ss_len = sizeof(struct sockaddr_in6);
+	((struct sockaddr_in6 *)&drloc)->sin6_addr = ip6->ip6_dst;
+	((struct sockaddr_in6 *)&srloc)->sin6_addr = ip6->ip6_src;
+
+	/* Save the value of the TTL in order to copy it back in the 
+	 * inner header.
+	 */
+	saved_hlim= ip6->ip6_hlim;
+
+	/* GgX - off already counts for the ip6hdr. */
+	m_adj(m, (off + sizeof(struct udphdr)));
+
+	m_copylisphdr(&m, &rlisphdr);
+
+	/*  Strip Lisp Shim Header */
+	m_adj(m, sizeof(struct lispshimhdr));
+
+	/* XXX - There is at least an IPv4 header */
+	m = m_pullup(m, sizeof(struct ip));
+	ip = mtod(m, struct ip *);
+
+	switch (ip->ip_v) {
+	
+	case IPVERSION:
+
+	        lisp4stat.ioafpackets++;
+
+	        error = lisp_check_ip_mappings( &m, &drloc, &srloc, 
+						&rlisphdr );
+
+		if (error)
+		        goto lisp6_input_drop;
+
+		delta_ttl = ip->ip_ttl - saved_hlim;
+		ip->ip_ttl = (u_char) saved_hlim;
+
+	       /* Update Checksum due to TTL recalculation 
+		*/
+		if (ip->ip_sum >= (u_int16_t) ~htons(delta_ttl << 8))
+		        ip->ip_sum -= ~htons(delta_ttl << 8);
+		else
+		        ip->ip_sum += htons(delta_ttl << 8);
+
+ 	
+ 	        isr = NETISR_IP;
+
+		break;
+
+	case (IPV6_VERSION >> 4):
+
+	        error = lisp_check_ip6_mappings( &m, &drloc, &srloc, 
+						 &rlisphdr );
+
+		if (error)
+		        goto lisp6_input_drop;
+
+		ip6 = mtod(m, struct ip6_hdr *);
+		
+		ip6->ip6_hlim = saved_hlim;
+		
+ 	        isr = NETISR_IPV6;
+
+		break;
+
+	default:
+	  
+#ifdef LISP_DEBUG
+	        DEBUGLISP("[LISP6_INPUT] Drop! Unrecongnized inner packet AF\n");
+#endif /* LISP_DEBUG */
+
+	        lisp6stat.ihdrops++;
+	        goto lisp6_input_drop;
+
+	};
+
+	netisr_dispatch(isr, m);
+
+	return (IPPROTO_DONE);
+
+lisp6_input_drop:	
+
+	if (m)
+		m_freem(m);
+
+	return (IPPROTO_DONE);
+
+}  /* lisp6_input() */
+
+
+
+int
+lisp6_output(struct mbuf *m, int hlen, struct eidmap *local_map, struct eidmap *remote_map)
+{
+	register int len = m->m_pkthdr.len;
+	struct locator * srcrloc;
+	struct locator * dstrloc;
+	int error = 0;
+	u_char saved_hlim;
+	uint16_t usrcport;
+
+	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
+
+	KASSERT(local_map->mapping,"[LISP6_OUTPUT] Output without local mapping");
+	KASSERT(m, "[LISP6_OUTPUT] Output without packet");
+
+	if (remote_map == NULL)  {
+	        /* There is no mapping for the destination EID.
+		 * Do not set error, so that we silently drop
+		 */
+
+	         lisp6stat.omissdrops++;
+		 goto lisp6_output_drop;
+		 
+	};
+
+
+       /* Fix the IP header before going further, then 
+	* encapsulate.
+	*/
+	
+	if (m->m_pkthdr.csum_flags & CSUM_DELAY_DATA) {
+	        in_delayed_cksum(m);
+		m->m_pkthdr.csum_flags &= ~CSUM_DELAY_DATA;
+	};
+  	
+	ip6->ip6_plen = htons((len - sizeof(struct ip6_hdr)));
+
+	/* Save original TTL value to copy it back in the new outer header.
+	 */
+	saved_hlim = ip6->ip6_hlim;
+
+
+	/* Destination RLOC selection */
+	if ((error = map_select_dstrloc(remote_map->mapping, &dstrloc))) {
+	       /* There is no available RLOC that can be used 
+		*/
+
+	        lisp6stat.onorlocdrops++;
+	        goto lisp6_output_drop;
+
+	};
+	
+	/* If the MTU of the destination locator is set a check on 
+	 * the size is performed.
+	 */
+	if (dstrloc->rloc_metrix.rlocmtx.mtu &&
+	    ((len + sizeof(struct udphdr) + 
+	      SIZEOF_IPHDR(dstrloc->rloc_addr->ss_family) +
+	      sizeof(struct lispshimhdr)) > dstrloc->rloc_metrix.rlocmtx.mtu )) {
+		  
+	        error = EMSGSIZE;
+	        lisp6stat.osizedrops++;
+		goto lisp6_output_drop;
+	   
+	};
+		
+
+	/* Source RLOC selection 
+	 * Must match the destination RLOC AF (drloc_af)
+	 * and also be the address of the interface through which 
+	 * the packet will be sent 
+	 */
+	if ((error = map_select_srcrloc(local_map->mapping, dstrloc, 
+					&srcrloc))) {
+	       /* There is no available RLOC that can be used. 
+		*/
+
+	        lisp6stat.onorlocdrops++;
+	        goto lisp6_output_drop;
+
+	};
+
+	/* If the MTU of the source locator is set a check on the size
+	 * is performed.
+	 */
+	if (srcrloc->rloc_metrix.rlocmtx.mtu &&
+	    ((len + sizeof(struct udphdr) + 
+	      SIZEOF_IPHDR(srcrloc->rloc_addr->ss_family) + 
+	      sizeof(struct lispshimhdr)) > srcrloc->rloc_metrix.rlocmtx.mtu)) {
+
+		error = EMSGSIZE;
+	        lisp6stat.osizedrops++;
+		goto lisp6_output_drop;
+
+	};
+	
+
+	/* Global IPv6 MTU check 
+	 */
+	if (len + sizeof(struct udphdr) + 
+	    SIZEOF_IPHDR(srcrloc->rloc_addr->ss_family) +
+	    sizeof(struct lispshimhdr) > IPV6_MAXPACKET) {
+
+		error = EMSGSIZE;
+	        lisp6stat.osizedrops++;
+		goto lisp6_output_drop;
+
+	};
+	
+	/* Ready to encapsulate.
+	 * Before do it let's calculate the src port
+	 * Src port is hash based on the inner header.
+	 */
+
+	usrcport = get_lisp_srcport(&m);
+
+	m = m_lisphdrprepend(m, remote_map, local_map, dstrloc, srcrloc);
+
+	if (m == NULL) {
+
+		error = ENOBUFS;
+	        lisp6stat.onobufdrops++;
+		goto lisp6_output_drop;
+	};
+
+
+	switch (srcrloc->rloc_addr->ss_family) {
+	  
+	        case AF_INET:	 
+	
+		        lisp4stat.ooafpackets++;
+
+		        if ( !(error = lisp_ip_encap(&m,
+						     (len + sizeof(struct lispshimhdr)), 
+						     &((struct sockaddr_in *)srcrloc->rloc_addr)->sin_addr, 	     
+						     &((struct sockaddr_in *)dstrloc->rloc_addr)->sin_addr, 	     
+						     ((u_char) saved_hlim),
+						     usrcport))){
+			
+		                lisp4stat.opackets++;
+				error = ip_output(m, NULL, NULL, IP_LISP, NULL, NULL);
+
+			};
+			
+			FREE_EIDMAP(local_map);
+			FREE_EIDMAP(remote_map);
+
+			return(error);
+
+			break;
+
+                 case AF_INET6:
+
+		        if ( !(error = lisp_ip6_encap(&m, 
+						      (len + sizeof(struct lispshimhdr)), 
+						     &((struct sockaddr_in6 *)srcrloc->rloc_addr)->sin6_addr, 	     
+						     &((struct sockaddr_in6 *)dstrloc->rloc_addr)->sin6_addr, 
+						      saved_hlim,
+						      usrcport))) {
+			
+		                lisp6stat.opackets++;
+				error = ip6_output(m, NULL, NULL, IP_LISP, NULL, NULL, NULL);
+
+			};
+
+			FREE_EIDMAP(local_map);
+			FREE_EIDMAP(remote_map);
+
+			return(error);
+
+			break;
+
+	         default:
+	 	        error = EPFNOSUPPORT;
+	};  
+	
+
+lisp6_output_drop:
+
+	if (remote_map) {
+	        FREE_EIDMAP(remote_map);
+	};
+
+	FREE_EIDMAP(local_map);
+
+ 	m_freem(m);
+
+	lisp6stat.odrops++;
+	lisp6stat.opackets++;
+
+	return (error); 
+
+}   /* lisp6_output() */
+
+
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/netinet6/lisp6/ip6_lisp6.h freebsd-10.1.0-LISP/sys/netinet6/lisp6/ip6_lisp6.h
--- freebsd-10.1.0-RELEASE/sys/netinet6/lisp6/ip6_lisp6.h	1970-01-01 01:00:00.000000000 +0100
+++ freebsd-10.1.0-LISP/sys/netinet6/lisp6/ip6_lisp6.h	2014-12-14 13:47:08.849177058 +0100
@@ -0,0 +1,55 @@
+/*- /usr/src/sys/netinet6/lisp6/ip6_lisp.h
+ *
+ * Copyright (c) 2010 - 2011 The OpenLISP Project
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *  Contributors: 
+ *               Luigi Iannone <ggx@openlisp.org>
+ *
+ * $Id: ip6_lisp6.h 178 2011-09-22 14:50:11Z ggx $
+ *
+ */
+
+#ifndef _IP6_LISP_H_
+#define _IP6_LISP_H_
+
+
+int lisp_check_ip6_mappings(struct mbuf **, struct sockaddr_storage *,
+			    struct sockaddr_storage *, struct lispshimhdr *);
+
+int lisp_ip6_encap(struct mbuf **, int,	struct in6_addr *, struct in6_addr *,
+		   int, uint16_t);
+
+
+int lisp_ip6_needdecap(struct mbuf **, int, int);
+
+int lisp_ip6_mapencap(struct mbuf **, int, struct eidmap **, struct eidmap **);
+
+int lisp6_input(struct mbuf **, int *, int);
+int lisp6_output(struct mbuf *, int, struct eidmap *, struct eidmap *);
+
+
+#endif /*_IP6_LISP_H_*/
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/sys/mbuf.h freebsd-10.1.0-LISP/sys/sys/mbuf.h
--- freebsd-10.1.0-RELEASE/sys/sys/mbuf.h	2014-12-05 22:13:21.077658355 +0100
+++ freebsd-10.1.0-LISP/sys/sys/mbuf.h	2014-12-14 13:47:08.849177058 +0100
@@ -37,6 +37,7 @@
 /* XXX: These includes suck. Sorry! */
 #include <sys/queue.h>
 #ifdef _KERNEL
+#include "opt_lisp.h"
 #include <sys/systm.h>
 #include <vm/uma.h>
 #ifdef WITNESS
@@ -1029,6 +1030,9 @@
 #define	PACKET_TAG_CARP				28 /* CARP info */
 #define	PACKET_TAG_IPSEC_NAT_T_PORTS		29 /* two uint16_t */
 #define	PACKET_TAG_ND_OUTGOING			30 /* ND outgoing */
+#ifdef LISP
+#define	PACKET_TAG_MAPSOCKFAM			31 /* mapsock sa family*/
+#endif /* LISP */
 
 /* Specific cookies and tags. */
 
diff '-x=.svn' -ruN freebsd-10.1.0-RELEASE/sys/sys/socket.h freebsd-10.1.0-LISP/sys/sys/socket.h
--- freebsd-10.1.0-RELEASE/sys/sys/socket.h	2014-12-05 22:13:16.723482318 +0100
+++ freebsd-10.1.0-LISP/sys/sys/socket.h	2014-12-14 13:47:08.853179059 +0100
@@ -232,7 +232,11 @@
 #define	AF_IEEE80211	37		/* IEEE 802.11 protocol */
 #define	AF_INET_SDP	40		/* OFED Socket Direct Protocol ipv4 */
 #define	AF_INET6_SDP	42		/* OFED Socket Direct Protocol ipv6 */
-#define	AF_MAX		42
+#define AF_MAP          44		/* MAP family to create Mapping Sockets
+					 * in order to manage mappings from the
+					 * user space
+					 */
+#define	AF_MAX		44
 /*
  * When allocating a new AF_ constant, please only allocate
  * even numbered constants for FreeBSD until 134 as odd numbered AF_
@@ -357,6 +361,7 @@
 #define	PF_IEEE80211	AF_IEEE80211
 #define	PF_INET_SDP	AF_INET_SDP
 #define	PF_INET6_SDP	AF_INET6_SDP
+#define PF_MAP          AF_MAP
 
 #define	PF_MAX		AF_MAX
 
@@ -386,6 +391,13 @@
 					 * versions of msghdr structs. */
 #define	NET_RT_MAXID	6
 
+/*
+ * PF_MAP - OpenLISP Support for LISP Mapping Tables
+ */
+#define NET_MAPTBL_DUMP         1     /* dump */
+#define NET_MAPTBL_FLAGS        2     /* flags */
+#define NET_MAPTBL_MAXID        3
+
 #endif /* __BSD_VISIBLE */
 
 /*
